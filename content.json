{"meta":{"title":"kala的博客","subtitle":"个人学习笔记、踩坑记录、感悟分享","description":"kala的博客","author":"kala","url":"http://blog.c2wei.cn","root":"/"},"pages":[{"title":"archives","date":"2019-12-12T09:38:38.000Z","updated":"2019-12-14T16:05:50.038Z","comments":true,"path":"archives/index.html","permalink":"http://blog.c2wei.cn/archives/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-03-06T09:33:33.375Z","updated":"2020-03-06T09:33:33.368Z","comments":true,"path":"about/index.html","permalink":"http://blog.c2wei.cn/about/index.html","excerpt":"","text":"我叫陈禄伟，现大四狗一枚，坐标山东烟台。 2016年填志愿，迷迷糊糊的来到了烟台。 大一加入鲁大学生网网络技术部，开始接触web开发，但一直没有当回事，从大二开始认真自学，在大二上学期写出了自己的小网站。 大学最有意义的就是在学生网的日子，认识了一群朋友，把技术传承给了学弟学妹们，同时做了几个实用性的项目。 几年来接了许多私活，包括公司主页、商城、CMS、微信小程序等，用自己的知识赚了许多钱。 平时喜欢钻研技术，把写代码作为娱乐方式，享受解决问题和实现目标的成就感，就像是其他人在玩游戏。 技术栈用过Vue ThinkPHP jQuery Yaf WePY SpringBoot等，从没感觉自己技术有多好，还需要好好努力，很菜很菜，个人认为学习能力和解决问题能力最重要。 考研结束了。 到现在还是偶尔会后悔自己没有在大三去实习，拿到实习机会比考研是要容易一些，而且直接工作它有更大的确定性，毕竟考研很可能是只身一人在日出日落中默默奋斗后只留下一段奋斗的回忆，我怕是只得到一段回忆了。 好在现在考研初试已经落幕了，不要再想过去，把精力和注意力放在当前和下一步上。只要努力总会进步，就算没有什么结果，知识也不会亏待自己。我相信自己，即使我的学历不能更进一步，我也会成为一个优秀的人，一个优秀的程序员。 虽然专业不是计算机相关，但因为一些际遇，代码慢慢的渗透了我的生活，我也逐渐的接受并喜欢上了这个神奇的存在。 没有改变世界的口号，也不梦想拥有财富，只有一份执着，点点滴滴的汇聚，慢慢探索.。我相信总有一天，我会成为大牛。 每一天都要加油！"},{"title":"标签","date":"2019-12-12T09:37:27.000Z","updated":"2019-12-12T09:45:49.634Z","comments":true,"path":"tags/index.next.html","permalink":"http://blog.c2wei.cn/tags/index.next.html","excerpt":"","text":""},{"title":"分类","date":"2019-12-12T09:39:12.000Z","updated":"2019-12-12T09:44:52.348Z","comments":true,"path":"categories/index.next.html","permalink":"http://blog.c2wei.cn/categories/index.next.html","excerpt":"","text":""},{"title":"","date":"2019-12-14T15:32:20.447Z","updated":"2019-12-14T14:20:18.810Z","comments":false,"path":"categories/index.html","permalink":"http://blog.c2wei.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-14T15:11:40.459Z","updated":"2019-12-14T15:11:40.459Z","comments":false,"path":"tags/index.html","permalink":"http://blog.c2wei.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"做一个“福卡”翻转切换动效","slug":"做一个“福卡”翻转切换动效","date":"2020-01-15T12:09:43.000Z","updated":"2020-03-11T11:13:13.994Z","comments":true,"path":"2020/01/15/做一个“福卡”翻转切换动效/","link":"","permalink":"http://blog.c2wei.cn/2020/01/15/%E5%81%9A%E4%B8%80%E4%B8%AA%E2%80%9C%E7%A6%8F%E5%8D%A1%E2%80%9D%E7%BF%BB%E8%BD%AC%E5%88%87%E6%8D%A2%E5%8A%A8%E6%95%88/","excerpt":"","text":"最近在玩支付宝的集福卡活动，在福卡界面滑动福卡和翻转福卡时，心里不禁想，要不自己实现一个福卡切换翻转动效？ 说干就干，先明确下要实现的效果 布局 当前展示卡片居中 屏幕可以看到左右两边卡的一小块 动画效果 平滑滑动 翻转效果 其实没有很复杂，本次模仿只侧重动效，所以卡片里不放按钮图文等内容，做一些空卡片，翻转效果点击卡片即翻转 布局html 1&lt;!-- 展示容器 --&gt;2&lt;div class=\"card-list-wrap\"&gt; 3 &lt;!-- 卡片列表 --&gt;4 &lt;ul class=\"card-list\"&gt;5 &lt;!-- 卡片容器 --&gt;6 &lt;li class=\"card-item\"&gt;7 &lt;!-- 卡片内容 --&gt;8 &lt;div class=\"card-content\"&gt;9 &lt;div class=\"card-front\"&gt;&lt;/div&gt;10 &lt;div class=\"card-back\"&gt;&lt;/div&gt;11 &lt;/div&gt;12 &lt;/li&gt;13 14 &lt;li class=\"card-item\"&gt;15 &lt;div class=\"card-content\"&gt;16 &lt;div class=\"card-front\"&gt;&lt;/div&gt;17 &lt;div class=\"card-back\"&gt;&lt;/div&gt;18 &lt;/div&gt;19 &lt;/li&gt;20 21 &lt;li class=\"card-item\"&gt;22 &lt;div class=\"card-content\"&gt;23 &lt;div class=\"card-front\"&gt;&lt;/div&gt;24 &lt;div class=\"card-back\"&gt;&lt;/div&gt;25 &lt;/div&gt;26 &lt;/li&gt;27 28 .....更多卡片29 &lt;/ul&gt;30&lt;/div&gt; css 卡片左右滑动使用了css transform属性的translate3d配合h5的touch事件实现 1* &#123;2 margin: 0;3 padding: 0;4&#125;5html, body &#123;6 height: 100%;7 /* 禁止浏览器的左右滑动 */8 overflow: hidden;9&#125;10ul,li &#123;11 list-style-type: none;12&#125;13.card-list-wrap &#123;14 width: 300px;15 height: 500px;16 margin: 20px auto;17&#125;18.card-list &#123;19 /* 使用flex布局将卡片排成一行 */20 display: flex;21 /* 宽度=卡片数量*100% */22 width: 300%;23 height: 100%;24&#125;25.card-item &#123;26 /* flex:1看我另一篇笔记 */27 flex: 1;28 height: 100%;29 /* 卡片之间的边距 为什么不用margin？ */30 padding-left: 10px;31 padding-right: 10px;32 /* 卡片左右滑动动效 */33 transform: translate3d(0%, 0, 0);34 transition: all .6s ease;35&#125;36.card-content &#123;37 position: relative;38 height: 100%;39 /* 卡片翻转时缩放动效 */40 transition: all 0.5s ease;41 transform: scale(1);42&#125;43/* 以下是左右翻转的样式 可以参考我另一篇笔记 */44.card-front,45.card-back &#123;46 position: absolute;47 width: 100%;48 height: 100%;49 transition: transform 1s ease;50 backface-visibility: hidden;51&#125;52.card-front &#123;53 transform: rotateY(0deg);54 background-color: #1E9FFF;55&#125; 56.card-back &#123;57 transform: rotateY(180deg);58 background-color: #EE82EE;59&#125; 参考的笔记： h5 touch事件简单使用 flex:1;背后的知识 用css3写一个翻牌动效 js1&lt;script type=\"text/javascript\"&gt;2 let cardListWrap = document.querySelector('.card-list-wrap')3 /* 左右滑动效果 */4 let touch = &#123;&#125; //存放滑动开始结束时的手指触碰的屏幕位置横坐标5 // 滑动开始事件6 cardListWrap.addEventListener('touchstart', evt =&gt; &#123;7 touch.startX = evt.touches[0].clientX8 touch.endX = 09 &#125;)10 // 连续滑动一段距离后11 cardListWrap.addEventListener('touchmove', evt =&gt; &#123;12 touch.endX = evt.touches[0].clientX13 &#125;)14 // 滑动结束时15 cardListWrap.addEventListener('touchend', () =&gt; &#123;16 if (!touch.endX || Math.abs(touch.endX - touch.startX) &lt; 10) &#123;17 return18 &#125;19 // 根据起始结束的横坐标判断左右切换20 if (touch.endX &lt; touch.startX) &#123;21 nextCard()22 &#125; else &#123;23 prevCard()24 &#125;25 &#125;)26 // 左右切换的实现27 let count = 028 let cardItemList = document.querySelectorAll('.card-list')29 let apply = () =&gt; &#123;30 for (let i = 0; i &lt; cardItemList.length; i ++) &#123;31 cardItemList[i].style.transform = `translate3d($&#123;count*100&#125;%, 0, 0)`32 &#125;33 &#125;34 let nextCard = () =&gt; &#123;35 if (count &lt;= -2) return36 count--37 apply()38 &#125;39 let prevCard = () =&gt; &#123;40 if (count &gt;= 0) return41 count++42 apply()43 &#125;44 45 /* 点击反转效果 */46 // 修改元素旋转角度的函数47 let rotate = (obj, angle, xy) =&gt; &#123;48 obj.style.transform = 'rotate' + xy + '(' + angle + 'deg)';49 &#125;50 //翻转事件51 let event = (e) =&gt; &#123; 52 let tar = e.target53 tar = (tar.getAttribute('class').indexOf('back') != -1 || tar.getAttribute('class').indexOf('front') != -1 ) ? tar.parentNode : tar;54 // .card缩小后放大55 tar.style.transform = `scale(0.9)`56 tar.addEventListener(\"transitionend\", () =&gt; &#123;57 tar.style.transform = `scale(1)`58 &#125;)59 // 正反面翻转60 let face = tar.getAttribute('data-face')61 if (face == 'back') &#123;62 rotate(tar.querySelector('.card-front'), 0, 'Y')63 rotate(tar.querySelector('.card-back'), 180, 'Y') 64 tar.setAttribute('data-face', 'front')65 &#125; else &#123;66 rotate(tar.querySelector('.card-front'), 180, 'Y')67 rotate(tar.querySelector('.card-back'), 0, 'Y')68 tar.setAttribute('data-face', 'back') 69 &#125;70 &#125;71 cardListWrap.addEventListener('click', event)72&lt;/script&gt; 在线预览：http://d.c2wei.cn/card.html","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://blog.c2wei.cn/tags/css/"}]},{"title":"typora插入的图片在hexo正常显示","slug":"typora插入的图片在hexo正常显示","date":"2019-12-25T09:00:32.000Z","updated":"2020-03-07T13:14:10.424Z","comments":true,"path":"2019/12/25/typora插入的图片在hexo正常显示/","link":"","permalink":"http://blog.c2wei.cn/2019/12/25/typora%E6%8F%92%E5%85%A5%E7%9A%84%E5%9B%BE%E7%89%87%E5%9C%A8hexo%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/","excerpt":"","text":"我平时写md喜欢用typora，编辑hexo博客文章也是用typora，typora可以方便的插入图片，并且截图后能够直接粘贴到文档中 但是typora引用图片的路径都是本地绝对路径，不能够在hexo文章中显示 我分两步记录typora插入图片并在hexo博客中显示的过程，首先是hexo如何添加本地图片，然后是通过脚本将typora添加的图片移动到hexo能够使用的位置 hexo添加本地图片网上可以搜到很多教程文章，基本都雷同，大致步骤是： 在_config.yml配置文件中设置 1post_asset_folder: true 修改配置后会在hexo new &lt;article&gt;时为每篇文章在_post下建立一个同名资源目录，用于存放图片等资源 再安装一个插件hexo-asset-image用于上传本地图片 1npm install hexo-asset-image --save 现在把图片放到文章同名资源目录下，然后在文章中使用![](folder/pic.png)引入图片，folder代表的是文章同名资源目录，pic.png是引入的图片 执行hexo generate，本地图片添加完毕 以上是网上搜到的步骤，看起来挺简单。。。。。 但是事情并没有这么简单，hexo-asset-image这个插件在hexo3.0+存在bug，上传图片后生成的链接并不可用，所以需要修改这个插件的代码，这里参考了一位大佬的修改 在博客目录里编辑.node_modules/hexo-asset-image/index.js ，将内容替换为以下： 1'use strict';2var cheerio = require('cheerio');34// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string5function getPosition(str, m, i) &#123;6 return str.split(m, i).join(m).length;7&#125;89var version = String(hexo.version).split('.');10hexo.extend.filter.register('after_post_render', function(data)&#123;11 var config = hexo.config;12 if(config.post_asset_folder)&#123;13 var link = data.permalink;14 if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)15 var beginPos = getPosition(link, '/', 1) + 1;16 else17 var beginPos = getPosition(link, '/', 3) + 1;18 // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".19 var endPos = link.lastIndexOf('/') + 1;20 link = link.substring(beginPos, endPos);2122 var toprocess = ['excerpt', 'more', 'content'];23 for(var i = 0; i &lt; toprocess.length; i++)&#123;24 var key = toprocess[i];25 26 var $ = cheerio.load(data[key], &#123;27 ignoreWhitespace: false,28 xmlMode: false,29 lowerCaseTags: false,30 decodeEntities: false31 &#125;);3233 $('img').each(function()&#123;34 if ($(this).attr('src'))&#123;35 // For windows style path, we replace '\\' to '/'.36 var src = $(this).attr('src').replace('\\\\', '/');37 if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp;38 !/^\\s*\\//.test(src)) &#123;39 // For \"about\" page, the first part of \"src\" can't be removed.40 // In addition, to support multi-level local directory.41 var linkArray = link.split('/').filter(function(elem)&#123;42 return elem != '';43 &#125;);44 var srcArray = src.split('/').filter(function(elem)&#123;45 return elem != '' &amp;&amp; elem != '.';46 &#125;);47 if(srcArray.length &gt; 1)48 srcArray.shift();49 src = srcArray.join('/');50 $(this).attr('src', config.root + link + src);51 console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src);52 &#125;53 &#125;else&#123;54 console.info&amp;&amp;console.info(\"no src attr, skipped...\");55 console.info&amp;&amp;console.info($(this));56 &#125;57 &#125;);58 data[key] = $.html();59 &#125;60 &#125;61&#125;); 保存后再添加图片，就正常了 大佬文章链接：https://blog.csdn.net/xjm850552586/article/details/84101345 typora图片-&gt;hexo图片刚才是hexo添加本地图片的步骤，现在把typora添加的本地图片让hexo也能使用 typora插入图片是引入图片在本地的绝对路径，hexo添加本地图片需要图片在文章资源目录中 思路是编写一个脚本，将图片移动到hexo文章资源目录，再修改文章中的图片引用路径，使其符合hexo的方式 在hexo博客根目录新建movepic.js，内容如下 1const fs = require(\"fs\");23const param = process.argv.splice(2)[0]4let path = \"source/_posts/\"+param5let shortPath = param+\"/\"67fs.readFile(path + \".md\", (err, data) =&gt; &#123;8 if (err) &#123;9 console.log(err)10 return11 &#125;12 // 读取文章内容 13 let content = data.toString()14 // 提取出图片15 let rlt = content.match(/!\\[.*\\]\\(.*\\)/g)16 17 if (rlt.length &lt; 1) &#123;18 return \"本文章没有图片\"19 &#125;20 // 提取图片路径21 let picList = rlt.map(item =&gt; &#123;22 return item.split('(')[1].split(')')[0]23 &#125;)24 25 for (let i = 0; i &lt; picList.length; i ++) &#123;26 let fileType = picList[i].split('.')[1] //图片类型27 let newPath = path+'/'+i+'.'+fileType //asset28 let newShortPath = shortPath+i+'.'+fileType //博文内引用路径29 // 替换文章内容中的图片地址30 content = content.replace(picList[i], newShortPath);31 // 将图片移动到文章对应asset目录32 fs.rename(picList[i], newPath, (err) =&gt; &#123;33 if (err) &#123;34 console.log(err)35 return36 &#125;37 // 写入文件38 if (i == picList.length-1) &#123;39 fs.writeFile(path+\".md\", content, (err) =&gt; &#123;40 if (err) &#123;41 console.log(err)42 return43 &#125;44 console.log(\"done\")45 &#125;)46 &#125;47 &#125;)48 &#125;49&#125;) 运行方式，在blog根目录 1node movepic.js &quot;文章名称&quot; 这个脚本会自动完成对应文章内的图片引用修改，并将图片移动到hexo中文章资源目录下 可以愉快的使用了！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.c2wei.cn/tags/hexo/"}]},{"title":"hexo搭建个人博客","slug":"hexo搭建个人博客","date":"2019-09-11T10:16:06.000Z","updated":"2019-12-20T04:04:45.463Z","comments":true,"path":"2019/09/11/hexo搭建个人博客/","link":"","permalink":"http://blog.c2wei.cn/2019/09/11/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"hexo是一个简洁高效美观的静态博客，拥有许多主题和拓展，功能丰富，部署和写作方便，完美支持md。 hexo基于nodejs驱动，因此开始前本地先配置好nodejs环境，服务器仅需要一个服务器软件（推荐nginx）。 以下为安装配置hexo、安装next主题美化、及写作并发布到服务器的过程。","text":"hexo是一个简洁高效美观的静态博客，拥有许多主题和拓展，功能丰富，部署和写作方便，完美支持md。 hexo基于nodejs驱动，因此开始前本地先配置好nodejs环境，服务器仅需要一个服务器软件（推荐nginx）。 以下为安装配置hexo、安装next主题美化、及写作并发布到服务器的过程。 安装hexo和添加主题安装hexo本部分在本地电脑进行 命令行执行 1npm install -g hexo-cli 创建博客 选择一个合适的位置进行，以后新建、编辑及删除文章都将在这个目录下 1hexo init blog2cd blog3npm install 编辑配置 1vim _config.yml 现在先简单修改以下几项 1title: Hexo #站点的标题2subtitle: #站点的副标题3description: #站点的描述，写一段话来介绍你的博客吧:)，主要为SEO使用4author: #显示的文章作者名字5language: #语言。简体中文是zh6timezone: #时区，可以不配置，默认以本地时区为准 保存完毕后，执行 1hexo server 在浏览器访问localhost:4000可以看到大概了 安装next主题进行美化命令行进入上一步的博客目录 1cd blog2git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next 编辑配置文件 1vim _config.yml 找到theme项 1theme: next 现在重新执行hexo server可以看到主题已经修改了 修改主题配置 1vim themes&#x2F;next&#x2F;_config.yml 搜索下面的项并修改 scheme定义了主题的外观，Pisces是常用的双栏布局，人气较高 1#scheme: Muse2#scheme: Mist3scheme: Pisces language定义语言，改为简体中文 1language: zh-Hans 添加头像，头像图片文件放在主题目录的source/images下，即/blog/themes/next/source/images/avatar.png 1avatar: &#x2F;images&#x2F;avatar.png 文章编辑等常用命令新建一篇文章，执行命令 1hexo new &quot;文章标题&quot; 执行新建命令后会在blog/source/_posts下生成一个md文件，用自己顺手的编辑器打开编辑即可，每次文章变动后，需要执行以下命令，编译生成静态文件 1hexo generate 本地文件同步到服务器，执行如下部署命令 1hexo deploy 但是需要先配置服务器信息 部署到服务器hexo的一键部署功能可以方便的将生成的静态文件推送到远程git仓库(或是其它库) 我使用webhooks完成网站在服务器的自动更新部署 本文用的是gitee，使用github基本一样，github-webhooks 添加git仓库地址到hexo配置首先在gitee网站建立一个git仓库 然后修改本地配置文件_config.yml 1# Deployment2## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html3deploy:4 type: &#39;git&#39;5 repo: &#39;https:&#x2F;&#x2F;gitee.com&#x2F;username&#x2F;blog-hexo.git&#39; #git仓库地址 安装一个hexo插件 1npm install hexo-deploy-git --save 现在执行hexo deploy就会发现已经能推送到git仓库了 克隆仓库到服务器将仓库clone到服务器上的一个位置，如/home/wwwroot/ 1cd &#x2F;home&#x2F;wwwroot2git clone 仓库git地址 我的仓库名是blog，因此得到了/home/wwwroot/blog目录 编辑服务器配置将期望的域名解析到这个目录 查看执行php程序的用户登录自己的服务器 编辑php.ini，确保解锁system,shell_exec函数 可以通过如下php文件查看服务器是用哪个用户执行php程序的 1&lt;?php2system(\"whoami\"); 浏览器访问以上php文件可以看到结果（一定要用浏览器），我的是www用户 将/home/wwwroot/blog的所有者设为该www用户 1chown -R www:www /home/wwwroot/blog 配置部署公钥到服务器www用户目录下建立ssh密钥 1cd &#x2F;home&#x2F;www2sudo -Hu www ssh-keygen -t rsa -C &quot;your_name@example.com&quot; 3&#x2F;&#x2F;注意改为自己的邮箱 查看密钥内容并复制 1cat &#x2F;home&#x2F;www&#x2F;.ssh&#x2F;id_rsa.pub 到gitee打开仓库的设置页-&gt;部署公钥设置，新建一个公钥并填入 配置webhooks打开仓库设置-&gt;webhooks-&gt;添加webhooks 有两个参数 URL：能访问到自己的服务器即可，例如example.com/hooks.php 该地址只要和博客在一台服务器上即可，不一定为博客地址或在博客地址下 密码：随意填写一个，用于检验，例如填写kalakala 选择事件只勾选push，同时勾选激活，点击添加 在服务器对应位置编辑hooks.php，内容如下 1&lt;?php2$secret = \"kalakala\"; //密钥，和 Gitee 上对应3if ($_SERVER[\"HTTP_X_GITEE_TOKEN\"] == $secret) &#123;4 $ret = shell_exec(\"cd /home/wwwroot/blog &amp;&amp; git pull 2&gt;&amp;1\");5 echo \"更新成功\";6 var_dump($ret);7&#125; else &#123;8 echo \"密钥错误\";9&#125; 随意修改一下博客文章内容，执行hexo generate再执行hexo deploy部署测试一下 已经可以自动更新部署了","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.c2wei.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://blog.c2wei.cn/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"php禁用eval","slug":"php禁用eval","date":"2019-04-18T09:11:16.000Z","updated":"2019-12-23T14:25:47.839Z","comments":true,"path":"2019/04/18/php禁用eval/","link":"","permalink":"http://blog.c2wei.cn/2019/04/18/php%E7%A6%81%E7%94%A8eval/","excerpt":"","text":"最近在做的一个项目，网站被人用图片挂木马了，图片里是一段PHP代码 1&lt;?php eval($_GET['k']); ?&gt; 虽然网站还不至于被随意宰割，但是这可不是个小问题，图片挂马这种东西我暂时还研究不透，就先把eval函数禁用吧 打开php.ini，找到disable_functions，添加上eval，保存重启php。。。 eval居然还能使用！修改disable_functions无法禁用eval()！ 语言结构和函数原来，eval在php中，并不是一个函数，它是一个语言结构，也叫做语言构造器，语言结构看起来和函数一样，实际上它是php语法的一部分，也就是一个关键字。 php执行时，函数都要被php解析器先进行解析，分解为语言结构才会进一步执行，就是说语言结构比函数效率更高。 语言结构除了无法被php.ini中的disable_functions禁用外，也不能作为回调函数。可以通过function_exists()判断函数和语言结构，如下写了一段代码判断几个常用的方法 1&lt;?php2$list = ['echo', 'print', 'isset', 'empty', 'eval', 'system', 'shell_exec','array_key_exists', 'array_map'];3$rlt = array_map(function($name) &#123;4 if (function_exists($name)) &#123;5 return $name.\":函数\";6 &#125; else &#123;7 return $name.\":语言结构\";8 &#125;9&#125;, $list);10print_r($list); 执行结果为 1Array2(3 [0] &#x3D;&gt; echo:语言结构4 [1] &#x3D;&gt; print:语言结构5 [2] &#x3D;&gt; isset:语言结构6 [3] &#x3D;&gt; empty:语言结构7 [4] &#x3D;&gt; eval:语言结构8 [5] &#x3D;&gt; system:函数9 [6] &#x3D;&gt; shell_exec:函数10 [7] &#x3D;&gt; array_key_exists:函数11 [8] &#x3D;&gt; array_map:函数12) 可以看到我们熟悉的isset，empty都是语言结构，尽管用起来和函数一样 禁用方法那怎么禁用eval呢？ 通过安装一个名为diseval的第三方拓展，这个拓展php5和php7都适用，拓展的github地址：PHP_diseval_extension 作者提供了安装脚本，不过我没有使用，感觉还是编译安装舒服 安装过程： 拉取仓库并切换到拓展源码目录 1git clone https:&#x2F;&#x2F;github.com&#x2F;mk-j&#x2F;PHP_diseval_extension.git2cd PHP_diseval_extension&#x2F;source 编译 1phpize2.&#x2F;configure --with-php-config&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin&#x2F;php-config #注意更改php-config地址3make4sudo make install 成功后出现.so文件的位置，复制一下 打开php.ini，添加extension = &quot;/your_path/diseval.so&quot;; 保存重启php，OK 下一步要研究图片挂马。。。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://blog.c2wei.cn/tags/php/"}]},{"title":"flex:1;背后的知识","slug":"flex-1-背后的知识","date":"2019-03-09T12:50:37.000Z","updated":"2020-03-11T11:11:05.286Z","comments":true,"path":"2019/03/09/flex-1-背后的知识/","link":"","permalink":"http://blog.c2wei.cn/2019/03/09/flex-1-%E8%83%8C%E5%90%8E%E7%9A%84%E7%9F%A5%E8%AF%86/","excerpt":"","text":"flex属性其实是三个属性的简写，分别是flex-grow、flex-shrink、flex-basis，因此有必要先了解这三个属性 三兄弟flex-growflex-grow设置元素相对于其它弹性盒子的扩展量，默认值为0，例如如下代码b的宽度是其它盒子的两倍 1&lt;style&gt;2 .flex-box &#123;3 display: flex;4 &#125;5 .box &#123;6 height: 50px;7 &#125;8 .a &#123;9 flex-grow: 1;10 background-color: red;11 &#125;12 .b &#123;13 flex-grow: 2;14 background-color: yellow;15 &#125;16 .c &#123;17 flex-grow: 1;18 background-color: blue;19 &#125;20&lt;/style&gt;21&lt;div class=\"flex-box\"&gt;22 &lt;div class=\"box a\"&gt;&lt;/div&gt;23 &lt;div class=\"box b\"&gt;&lt;/div&gt;24 &lt;div class=\"box c\"&gt;&lt;/div&gt;25&lt;/div&gt; flex-shrinkflex-shrink 属性指定了 flex 元素的收缩规则。默认值为1，flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。例如如下代码，b的收缩量明显比ab小 1&lt;style&gt;2 .flex-box &#123;3 display: flex;4 &#125;5 .box &#123;6 width: 100%;7 height: 50px;8 &#125;9 .a &#123;10 flex-shrink: 1;11 background-color: red;12 &#125;13 .b &#123;14 flex-shrink: 0.5;15 background-color: yellow;16 &#125;17 .c &#123;18 flex-shrink: 1;19 background-color: blue;20 &#125;21&lt;/style&gt;22&lt;div class=\"flex-box\"&gt;23 &lt;div class=\"box a\"&gt;&lt;/div&gt;24 &lt;div class=\"box b\"&gt;&lt;/div&gt;25 &lt;div class=\"box c\"&gt;&lt;/div&gt;26&lt;/div&gt; 说一下flex-shrink的计算规则，假定每个元素设置flex-shrink为任意整数x1、x2、x3 ······，且所有宽度总宽度为w1，容器宽度为w2，且w1大于w2，记超出量为w，即 w=w1-w2则超出量将被所有元素消化收缩，收缩量比例为x1:x2:x3:·····，计算公式为 1收缩量&#x3D;(xi&#x2F;(x1+x2+x3+···))*w 依据这个我们计算一下实例里的收缩量，实例里三个元素总宽为300%，容器宽度为100%，所以`w = w1 - w2 = 2*w2 各元素的收缩量 1a: (1&#x2F;2.5)*w &#x3D; 0.4*w &#x3D; 0.8*w22b: (0.5&#x2F;2.5)*w &#x3D; 0.2*w &#x3D; 0.4*w23c: (1&#x2F;2.5)*w &#x3D; 0.4*w &#x3D; 0.8*w2 flex-basis设置弹性元素的初始宽度，默认值为auto flex:1flex的设置规则为flex-grow flex-shrink flex-basis，默认值是0 1 auto， flex: auto;为 1 1 auto; flex: none;为0 0 auto; flex: 1;为1 1 0%; 详细规则（摘自https://segmentfault.com/q/1010000004080910）： 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0% 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0% 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1 应用flex:1常用来实现这样一个效果： 就是content将home和admin撑至两边，使用flex实现非常简单，只需要设置容器display: flex;和contentflex: 1; 1&lt;style type=\"text/css\"&gt;2.header &#123;3 display: flex;4&#125;5.content &#123;6 flex: 1;7&#125;8/* 背景和字体样式 */9.home, .content, .admin &#123;10 padding: 20px 20px;11 background-color: #FA6000;12 color: #fff;13 font-weight: bold;14&#125;1516&lt;/style&gt;17&lt;body&gt;18&lt;div class=\"header\"&gt;19 &lt;div class=\"home\"&gt;Home&lt;/div&gt;20 &lt;div class=\"content\"&gt;Content&lt;/div&gt;21 &lt;div class=\"admin\"&gt;Admin&lt;/div&gt;22&lt;/div&gt;23&lt;/body&gt; 学习flex布局强烈推荐阮一峰大大的两篇文章，我这文笔就不写了 Flex 布局教程：语法篇 Flex 布局教程：实例篇","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://blog.c2wei.cn/tags/css/"},{"name":"flex","slug":"flex","permalink":"http://blog.c2wei.cn/tags/flex/"}]},{"title":"h5 touch事件简单使用","slug":"h5-touch事件简单使用","date":"2018-11-09T12:51:21.000Z","updated":"2020-03-10T10:07:16.468Z","comments":true,"path":"2018/11/09/h5-touch事件简单使用/","link":"","permalink":"http://blog.c2wei.cn/2018/11/09/h5-touch%E4%BA%8B%E4%BB%B6%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"h5新增事件h5增加了一系列事件，比如麦克风、相机、拖拽、重力感应和移动设备触摸等 全触控智能手机在10年前后开始爆发时增长，手机浏览器也不断强化，因此h5制定的时候针对手机出现了一些独有API，如重力感应、touch触摸手势等，特别是触摸手势操作，改写了移动端的开发 touch事件移动设备touch操作有多个事件 touchstart当手指放到屏幕上时触发 touchmove当手指移动时触发，和滚轮、滑动事件一样，会不停触发 touchend当手指离开屏幕时触发 touchenter当手指滑入一个元素时 touchleave当手指滑出一个元素时 touchcancel较少用到，触控被打断时触发 event对象touch系列事件的每个事件对象都有三个触摸属性 touches：屏幕上的所有手指触摸点的一个列表 targetTouches：当前元素对象上所有触摸点的列表 changedTouches：涉及当前事件的触摸点的列表 每个触摸属性都是一个数组，数组中每个元素都代表一个触摸点 每个触摸点都有几个重要属性 identifier 触摸点的标识 clientX/clientY 触摸点相对于浏览器窗口左上顶点的坐标 pageX/pageY 触摸点相对于页面dom元素左上顶点的坐标，包含页面滚动造成的偏移量 screenX/screenY 触摸点相对于屏幕左上顶点的坐标 简单应用根据touch事件的API，我们可以完成各种各样的触摸操作，在复杂需求下我们可以借助一些库来完成，比如Touch.js、swiper.js等，这里只写几个简单的场景 简单的屏幕翻页以一个上下全屏翻页为例，这样的场景并不少见，使用css3的translate3d配合touch事件来翻页，css设置transition实现动效，思路很简单，监听触摸开始、移动、结束三个时间，通过判断触摸点的起始结束Y坐标，来判断上下翻页 页面html1&lt;div class=\"page no-1\"&gt;&lt;/div&gt;2&lt;div class=\"page no-2\"&gt;&lt;/div&gt;3&lt;div class=\"page no-3\"&gt;&lt;/div&gt; css1* &#123;2 margin: 0;3 padding: 0;4&#125;5html, body &#123;6 height: 100%;7 overflow: hidden;8&#125;9.page &#123;10 height: 100%;11 transition: all 0.6s ease;12&#125;13.no-1 &#123;14 background-color: #1E9FFF;15&#125;16.no-2 &#123;17 background-color: #FFB800;18&#125;19.no-3 &#123;20 background-color: #FF5722;21&#125; js1// 存放滑动开始结束的坐标2let touch = &#123;3 startY: null,4 endY: null5&#125;6// 滑动开始7document.addEventListener('touchstart', function() &#123;8 touch.startY = event.touches[0].clientY9 touch.endY = event.touches[0].clientY10&#125;)11// 滑动中 不断修改结束Y坐标12document.addEventListener('touchmove', function() &#123;13 touch.endY = event.touches[0].clientY14&#125;)15// 滑动结束16document.addEventListener('touchend', function() &#123;17 if (touch.startY &lt; touch.endY) &#123; //手指下滑 上翻页18 prevPage()19 &#125; else &#123; //否则下翻页20 nextPage()21 &#125;22&#125;)23// 当前展示的页面编号24let offsetIndex = 025// 上翻页26function prevPage() &#123;27 if (offsetIndex &lt;= 0) return28 offsetIndex--29 translate(offsetIndex)30&#125;31// 下翻页32function nextPage() &#123;33 if (offsetIndex &gt;= pageList.length-1) return34 offsetIndex ++35 translate(offsetIndex)36&#125;3738let pageList = document.querySelectorAll('.page')39// 页面滚动函数40function translate(index) &#123;41 pageList.forEach(item =&gt; &#123;42 item.style.transform = `translate3d(0, -$&#123;index*100&#125;%, 0)`43 &#125;)44&#125; 在线预览（需要移动设备） http://d.c2wei.cn/h5event/touch/page.html 判断用户长按长按手势也是常用的一个手势，可以通过监听滑动开始结束的时间间隔判断，同时还要判断滑动距离，不要滑动时产生误触发 html css1&lt;style&gt;2.block &#123;3 width: 200px;4 height: 200px;5 background-color: #0000FF;6&#125;7&lt;/style&gt;8&lt;div class=\"block\"&gt;&lt;/div&gt; js1/** 绑定长按事件的函数2 * @param &#123;Object&#125; html元素3 * @param &#123;Number&#125; 长按时间 单位秒4 * @param &#123;Object&#125; 发生长按后的回调函数5 */6function attachLongPress(el, time, callback) &#123;7 el.startTime = 08 el.startTouch = &#123;clientX: null, clientY: null&#125;9 el.timeout = null10 // 手指放到屏幕上11 el.addEventListener('touchstart', function() &#123;12 // 记录手指放下时的值13 el.startTime = new Date().getTime()14 el.startTouch.clientX = event.changedTouches[0].clientX15 el.startTouch.clientY = event.changedTouches[0].clientY16 // 设定一个定时器 长按时间达到后执行回调函数17 if (el.timeout) clearInterval(el.timeout)18 el.timeout = setTimeout(function() &#123;19 callback()20 &#125;, time*1000)21 &#125;)22 // 监听手指滑动 手指滑动了要取消定时器23 el.addEventListener('touchmove', function() &#123;24 let offsetTouch = &#123;25 clientX: event.changedTouches[0].clientX,26 clientY: event.changedTouches[0].clientY27 &#125;28 // 判断滑动距离 一旦大于10px取消定时器29 if (Math.abs(offsetTouch.clientX - el.startTouch.clientX) &gt; 10 &amp;&amp;30 Math.abs(offsetTouch.clientY - el.startTouch.clientY) &gt; 10) &#123;31 clearTimeout(el.timeout)32 &#125;33 &#125;)34 // 手指离开屏幕时 长按时间不足要取消定时器35 el.addEventListener('touchend', function() &#123;36 // 判断时间间隔 长按时间不足则取消定时器37 if (new Date().getTime() - el.startTime &lt; time*1000) &#123; 38 clearInterval(el.timeout)39 &#125;40 &#125;)41&#125;4243let block = document.querySelector('.block')44// 绑定自己实现的长按事件45attachLongPress(block, 1, function() &#123;46 alert(\"发生了长按\")47&#125;) 在线预览（需要移动设备） http://d.c2wei.cn/h5event/touch/long-press.html","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"},{"name":"touch","slug":"touch","permalink":"http://blog.c2wei.cn/tags/touch/"}]},{"title":"ubuntu18安装sublime及解决不能中文输入","slug":"ubuntu18安装sublime及解决不能中文输入","date":"2018-09-12T13:47:51.000Z","updated":"2019-12-15T12:01:02.686Z","comments":true,"path":"2018/09/12/ubuntu18安装sublime及解决不能中文输入/","link":"","permalink":"http://blog.c2wei.cn/2018/09/12/ubuntu18%E5%AE%89%E8%A3%85sublime%E5%8F%8A%E8%A7%A3%E5%86%B3%E4%B8%8D%E8%83%BD%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5/","excerpt":"","text":"ubuntu18更换了桌面环境，配置sublime启动器时略有不同，大概安装和ubuntu16一致 本文从头开始安装sublime并添加中文输入支持 安装sublime到 sublime官网下载linux可用的sublime_text_3程序包(非安装包) 解压后得到一个sublime_text_3文件夹 把文件夹移动到/opt/ 1mv sublime_text_3 &#x2F;opt&#x2F; 然后重命名为sublime_text 1mv &#x2F;opt&#x2F;sublime_text_3 &#x2F;opt&#x2F;sublime_text 现在sublime已经安装到了/opt/目录，但是还没有启动图标和无法使用中文输入法 下载和添加中文支持共享库下载我们需要的文件，打开终端，输入： 1git clone https:&#x2F;&#x2F;github.com&#x2F;lyfeyaj&#x2F;sublime-text-imfix.git 将subl移动到/usr/bin/，并且将sublime-imfix.so移动到/opt/sublime_text/（sublime的安装目录）终端输入： 1cd ~&#x2F;sublime-text-imfix2sudo cp .&#x2F;lib&#x2F;libsublime-imfix.so &#x2F;opt&#x2F;sublime_text&#x2F;3sudo cp .&#x2F;src&#x2F;subl &#x2F;usr&#x2F;bin&#x2F; 用subl命令试试能不能启动sublime，如果成功启动的话，应该就可以输入中文了。终端输入： 1LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl 配置启动图标新建文件sublime.desktop 1vim sublime.desktop 填入以下内容 1[Desktop Entry]2Version&#x3D;1.03Type&#x3D;Application4Name&#x3D;Sublime Text5GenericName&#x3D;Text Editor6Comment&#x3D;Sophisticated text editor for code, markup and prose7Exec&#x3D;bash -c &quot;LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl&quot;8Terminal&#x3D;false9MimeType&#x3D;text&#x2F;plain;10Icon&#x3D;sublime-text11Categories&#x3D;TextEditor;Development;12StartupNotify&#x3D;true13Actions&#x3D;Window;Document;1415[Desktop Action Window]16Name&#x3D;New Window17Exec&#x3D;bash -c &quot;LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl&quot;18OnlyShowIn&#x3D;Gnome;1920[Desktop Action Document]21Name&#x3D;New File22Exec&#x3D;bash -c &quot;LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl&quot;23OnlyShowIn&#x3D;Gnome; 保存后，修改文件权限 1chown 用户名:用户名 sublime.desktop2用户名为当前登录到ubuntu的用户名 在图形界面下找到文件，右击文件 选择属性-&gt;权限，勾选“允许作为可执行文件”，顺便查看一下用户组是否为当前用户 关闭属性界面，双击文件，选择“trust and lanuch” 如果能正常启动应用，就创建成功了 然后移动到/usr/share/applications 1mv sublime.desktop &#x2F;usr&#x2F;local&#x2F;applications&#x2F; 现在打开程序列表，就找到sublime的图标了 完成","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/tags/ubuntu/"},{"name":"sublime","slug":"sublime","permalink":"http://blog.c2wei.cn/tags/sublime/"}]},{"title":"ubuntu18添加应用到启动器","slug":"ubuntu18添加应用到启动器","date":"2018-08-12T08:45:00.000Z","updated":"2019-12-15T12:01:04.904Z","comments":true,"path":"2018/08/12/ubuntu18添加应用到启动器/","link":"","permalink":"http://blog.c2wei.cn/2018/08/12/ubuntu18%E6%B7%BB%E5%8A%A0%E5%BA%94%E7%94%A8%E5%88%B0%E5%90%AF%E5%8A%A8%E5%99%A8/","excerpt":"","text":"ubuntu18更换了桌面环境为Gnome，二进制文件启动的应用不能固定到dock，如sublime、idea等，需要自己创建启动图标并添加到启动器 首先创建一个后缀名为.desktop的文件 然后填入以下内容 1[Desktop Entry]2Name&#x3D;[软件名称]3Comment&#x3D;[软件介绍]45GenericName&#x3D;[注释，副标题]6Exec&#x3D;[启动命令，可执行文件路径或在环境变量中设定好的指令均可]7Icon&#x3D;[软件图标，png、svg都可以]8Type&#x3D;Application9StartupNotify&#x3D;true10Categories&#x3D;[软件分类目录]11MimeType&#x3D;[软件类型] 例： 1[Desktop Entry]2Name&#x3D;PyCharm3Comment&#x3D;Full-featured IDE for Python &amp; Web development4GenericName&#x3D;jetbrains PyCharm Professional5Exec&#x3D;charm6Icon&#x3D;&#x2F;opt&#x2F;pycharm&#x2F;bin&#x2F;pycharm.svg7Type&#x3D;Application8StartupNotify&#x3D;true9Categories&#x3D;Development;IDE;10MimeType&#x3D;Development;IDE; 保存 注意:该文件的所有权一定要是当前用户，即开机时登录的用户，这样才能对启动文件进行信任修改所有权的命令 1sudo chown 用户名:用户名 文件名 另外启动命令一定要正确 右击文件，选择属性-&gt;权限，勾选“允许作为可执行文件”，顺便查看一下用户组是否为当前用户 关闭属性界面，双击文件，选择“trust and lanuch” 如果能正常启动应用，就可以添加到桌面或是系统应用列表了 系统应用列表目录为/usr/share/applications/ 直接将文件移动到目录即可，启动器就会出现图标 右击应用列表中的应用图标会有添加到收藏夹，就可以添加到dock了","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/tags/ubuntu/"}]},{"title":"使用docker部署一个老项目","slug":"使用docker部署一个老项目","date":"2018-06-10T11:40:31.000Z","updated":"2020-01-21T00:51:08.804Z","comments":true,"path":"2018/06/10/使用docker部署一个老项目/","link":"","permalink":"http://blog.c2wei.cn/2018/06/10/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E8%80%81%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"docker是什么官方解释： Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 我看完了，emmmm这到底是个啥玩意，只是听说有了这个可以简化部署就来了，可这到底是个啥…… 这个东西有一点像虚拟机，但是性能开销远小于虚拟机，docker有镜像和容器，镜像就像是系统的镜像，并且包含了环境和一些特定配置。然后可以选择一个镜像来启动一个容器（类似于类-&gt;对象），然后我们将自己的应用程序放到容器里。 重点就是，可以解决配置环境不兼容的问题，简化部署 举一个最简单的例子，我的服务器是nginx+php7+mysql5.7的环境，并且运行着好几个网站，现在拿到了一个老网站，它只能用apache+php5.4+mysql5来运行，可我又没有其它服务器，又必须要把它跑起来，这时候怎么办？ 当然重构这个网站是一定不可能的，所以…… 是的，就用docker解决这个问题，我们选取一个带有apache+php5.4+mysql5的docker镜像，然后用这个镜像城建一个容器，或者自己编写Dockerfile文件创建一个容器，将老项目放到容器中，就可以解决问题了。 如何使用docker安装启用docker首先，安装docker 1wget -qO- https:&#x2F;&#x2F;get.docker.com&#x2F; | sh centos源里有docker 1yum -y install docker-io 然后启动docker服务 1sudo service docker start 之后我们会从docker的镜像仓库里下载镜像，默认用的是国外的，比较慢，我们替换成国内的 打开/etc/default/docker文件（需要sudo权限），在文件的底部加上一行。 1DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;https:&#x2F;&#x2F;registry.docker-cn.com&quot; 网易的镜像源也不错：http://hub-mirror.c.163.com 现在准备工作完成了。 部署项目搜索符合我们要求的镜像 1sudo docker search 关键字 我搜索关键字为php54，找到fbender/php54-apache-mysql镜像符合要求（那我就不编写Dockerfile了） 拉取镜像 1sudo docker pull fbender&#x2F;php54-apache-mysql 下载完成后，启动容器 1sudo docker run --name 自定义名称 -v ～&#x2F;docker&#x2F;www:&#x2F;var&#x2F;www&#x2F;html -d fbender&#x2F;php54-apache-mysql 解释一下： –name 为自定义的名称，可以后续作为该容器的标识 -v 将容器里的/var/www/html映射到本机的～/docker/www（要部署的网站放在本机的这个目录就可以了） -d 后台运行 然后将那个老网站放到映射到的本机目录 现在要获取这个容器分配到的ip 1sudo docker inspect 自定义的名称或容器id | grep &#39;&quot;IPAddress&quot;&#39; 我分配到的是172.17.0.3 浏览器输入172.17.0.3然后回车，这个老网站就出来了（服务器上当然没这个操作，ping一下或者curl吧） 一些常用命令查看当前运行中的容器 1sudo docker ps 查看运行中的容器（-a表示包括停止运行的） 1sudo docker ps2sudo docker ps -a 停止一个容器 1sudo docker stop 容器id或自定名称 重新启动容器 1sudo docker start 容器id或自定名称 删除一个容器 1sudo docker container rm 容器id或自定名称 以命令行交互模式打开容器(会打开一个伪终端) 11.第一次运行时2sudo docker run -it 镜像名称 bash32.运行中的4sudo docker exec -it 容器id或自定名称 bash 使用反向代理以上我们可以用一个ip访问，这样肯定达不到部署的要求 为了用域名访问，用nginx的反向代理功能吧 新建一个nginx的虚拟主机，配置如下 server { listen 80; #listen [::]:80; server_name 虚拟主机的域名 ; index index.html index.htm index.php; location / { proxy_pass http://docker分配到的ip; #Proxy Settings proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; proxy_max_temp_file_size 0; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; } }更多姿势以上是一个比较简单的使用，docker的功能非常强大 官方文档：https://docs.docker.com/ 推荐网址：http://www.docker.org.cn/ 阮一峰大大的入门文章： http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html 在上例中，只是对php有特定要求，其实完全可以配置只含有php的docker镜像 而且docker可以为项目量身定制容器，还要继续学习呀~","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.c2wei.cn/tags/docker/"}]},{"title":"0.1+0.2 != 0.3","slug":"0-1-0-2-0-3","date":"2018-05-31T12:50:08.000Z","updated":"2020-03-11T11:33:02.278Z","comments":true,"path":"2018/05/31/0-1-0-2-0-3/","link":"","permalink":"http://blog.c2wei.cn/2018/05/31/0-1-0-2-0-3/","excerpt":"","text":"问题js有一个问题，就是0.1+0.2 === 0.3表达式的值居然是false，但是0.1+0.3 === 0.4是true，好像有点玄幻？ 为什么其实这是个精度问题，计算机里的浮点数(即小数)都不是准确的，是按一定精度取得近似值，出现了精度损失 js的精度规则基本遵循IEEE 754-2008 规定的双精度浮点数规则，因为js还有NaN和正负无穷大，所以是基本遵循，但是NaN和正负无穷大和这里说的内容没有关系 众所周知，计算机是二进制的，我们习惯的十进制运算在计算机中要转换为二进制运算，因此在表示小数时，二进制结果只能无限趋近，永远不会等于 而0.1+0.2就是超出误差范围的一个，0.1+0.3或是其它的时候，它又进入了误差范围，抵消了精度损失 应该怎么做js在浮点数比较时，应该使用js语言提供的最小精度值进行比较，即 1Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"}]},{"title":"使用preventDefault阻止事件的默认行为","slug":"使用preventDefault阻止事件的默认行为","date":"2018-05-25T14:05:43.000Z","updated":"2020-03-10T00:39:13.930Z","comments":true,"path":"2018/05/25/使用preventDefault阻止事件的默认行为/","link":"","permalink":"http://blog.c2wei.cn/2018/05/25/%E4%BD%BF%E7%94%A8preventDefault%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA/","excerpt":"","text":"preventDefault函数是event对象的一个方法，用于取消事件的默认行为，比如点击a标签会跳转，使用该方法可以取消跳转，如下代码将不会发生跳转 1&lt;a id=\"link\" href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;2&lt;script type=\"text/javascript\"&gt;3 var link = document.querySelector('#link')4 link.addEventListener('click', function() &#123;5 event.preventDefault()6 console.log(\"不会跳转\")7 &#125;)8&lt;/script&gt; 可以通过event.cancelable判断事件默认行为能否被阻止，如果为false，则事件没有默认行为或不能被阻止 事件默认行为被阻止后，依然发生事件捕获或事件冒泡的传递 阻止点击事件的默认行为除了阻止a标签跳转外，还可以阻止复选框的选中 1&lt;form action=\"dologin.php\" method=\"post\"&gt;2 &lt;input type=\"checkbox\" name=\"test\" value=\"1\" /&gt;复选框3&lt;/form&gt;4&lt;script type=\"text/javascript\"&gt;5 var form = document.forms[0]6 form.test.addEventListener('click', function() &#123;7 event.preventDefault()8 console.log(\"你点击了，但并不会选中\")9 &#125;)10&lt;/script&gt; 阻止表单提交1&lt;form action=\"dologin.php\" method=\"post\"&gt;2 &lt;input type=\"checkbox\" name=\"test\" value=\"1\" /&gt;复选框3 &lt;button type=\"submit\"&gt;提交&lt;/button&gt;4&lt;/form&gt;5&lt;script type=\"text/javascript\"&gt;6 var form = document.forms[0]7 form.addEventListener('submit', function() &#123;8 event.preventDefault()9 console.log(\"你点击了提交，但并不会提交\")10 &#125;)11&lt;/script&gt; 阻止编辑框的按键按下1&lt;textarea id=\"editor\" rows=\"30\"&gt;2&lt;/textarea&gt;3&lt;script type=\"text/javascript\"&gt; 4 var editor = document.querySelector('#editor')5 editor.addEventListener('keydown', function() &#123;6 event.preventDefault()7 console.log(\"你按下了按键。但不会有反应\")8 &#125;)9&lt;/script&gt; 这样我们可以判断按下的按键来实现禁用ctrl+c和ctrl+v 1&lt;textarea id=\"editor\" rows=\"30\"&gt;2&lt;/textarea&gt;3&lt;script type=\"text/javascript\"&gt; 4 var editor = document.querySelector('#editor')5 6 let ctrl; 7 editor.addEventListener('keydown', function() &#123;8 // 禁用ctrl+c9 if (ctrl &amp;&amp; event.keyCode === 67) &#123;10 event.preventDefault()11 &#125;12 // 禁用ctrl+v13 if (ctrl &amp;&amp; event.keyCode === 86) &#123;14 event.preventDefault()15 &#125;16 // ctrl按下时ctrl变量为true17 if (event.keyCode === 17) &#123;18 ctrl = true19 &#125;20 &#125;)21 editor.addEventListener('keyup', function() &#123;22 // ctrl松开时ctrl变量为false23 if (event.keyCode === 17) &#123;24 ctrl = false25 &#125;26 &#125;)27&lt;/script&gt; 禁用鼠标右键配合禁用ctrlcv，就能实现禁用复制粘贴了 1document.addEventListener('contextmenu', function() &#123;2 event.preventDefault()3&#125;)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"},{"name":"事件","slug":"事件","permalink":"http://blog.c2wei.cn/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"禁用复制粘贴","slug":"禁用复制粘贴","permalink":"http://blog.c2wei.cn/tags/%E7%A6%81%E7%94%A8%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/"}]},{"title":"DOM事件","slug":"DOM事件","date":"2018-05-21T09:55:05.000Z","updated":"2020-03-07T02:33:35.475Z","comments":true,"path":"2018/05/21/DOM事件/","link":"","permalink":"http://blog.c2wei.cn/2018/05/21/DOM%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"事件机制事件注册事件绑定即通过形如onclick的方法注册事件，比如 1btn.onclick = function() &#123;2 console.log(\"hello\")3&#125;45area.onmouseover = function() &#123;6 console.log(\"hello\")7&#125; 还可以写到html里（极不提倡）： 1&lt;button onclick=\"handle\"&gt;点击&lt;/button&gt; 事件绑定无法为同一元素（节点）同一事件重复注册回调函数，后注册的回调函数会覆盖掉已经注册的回调函数，因为绑定的事件是作为元素的一个属性，回调函数是该属性的值 事件监听这是现在提倡的事件注册方式 addEventListener addEventListener(‘事件类型’, 回调函数, 布尔值|对象)，第三个参数使用布尔值时表示使用冒泡(false)还是捕获(true)，默认为false 第三个参数使用对象时有三个属性 capture：布尔值，true事件捕获false事件冒泡 once，布尔值，是否在回调执行后立即移除监听，即只调用一次回调函数 passive，布尔值，是否禁用 preventDefault 1button.addEventListener('click', handle, true)23button.addEventListener('click', function() &#123;4 console.log(\"您只会看到一次该消息\")5&#125;, &#123; capture: false, once: true, passive: true &#125;) removeEventListener removeEventListener(‘事件类型’, 回调函数, 布尔值)，即移除对应的监听，第三个参数表示在事件捕获阶段(true)还是事件冒泡阶段(false)移除，默认为false 1button.addEventListener('click', handle, true) 事件监听使用了事件池/事件队列机制，不再以属性方式，因此可以注册多个回调函数 使用监听的好处 可以为同一元素同一事件注册多个回调函数 可以灵活的控制事件冒泡事件捕获等行为 可以移除监听，释放内存 注意：IE6-8 不支持这一方法，但有类似的方法：EventTarget.attachEvent 事件冒泡和事件捕获默认行为js事件默认会在子元素触发事件时也触发父元素和上级元素注册的事件，按照触发顺序分为事件冒泡和事件捕获 如下代码，点击div.child时div.root和div.father上注册的事件也会触发 1&lt;div class=\"root\"&gt;2 &lt;div class=\"father\"&gt;3 &lt;div class=\"child\"&gt;&lt;/div&gt;4 &lt;/div&gt;5&lt;/div&gt;6&lt;script&gt;7 const get = function(selector) &#123;8 return document.querySelector(selector);9 &#125;1011 let root = get('.root'),12 father = get('.father'),13 child = get('.child')1415 const capture = true // true为捕获false为冒泡1617 root.addEventListener('click', function() &#123;18 alert(\"I'm root\")19 &#125;, capture);20 father.addEventListener('click', function() &#123;21 alert(\"I'm father\")22 &#125;, capture);23 child.addEventListener('click', function() &#123;24 alert(\"I'm child\")25 &#125;, capture);26&lt;/script&gt; 事件冒泡子元素事件触发时，按照子元素-&gt;父元素-&gt;上级元素的顺序触发注册的事件 设置变量capture为false，点击div.child时依次提示I&#39;m child，I&#39;m father，I&#39;m root 注意：当使用事件绑定时，也会有事件冒泡行为 事件捕获子元素事件触发时，按照上级元素-&gt;父元素-&gt;子元素的顺序触发注册的事件 设置变量capture为true，点击div.child时依次提示I&#39;m root，I&#39;m father，I&#39;m child 阻止传递使用event.stopPropagation()方法可以阻止事件捕获或事件冒泡的传递，该方法写在回调函数中 先捕获dom结构中可能会同时注册捕获和冒泡事件，此时先进行事件捕获 事件代理（事件委托）为目标节点的父元素或上级元素添加事件监听/绑定，利用事件冒泡行为，目标元素点击（触发事件）时触发上级元素注册的事件，在事件回调中判断实际点击（触发事件）的目标并实现操作。称为事件代理，也叫做事件委托 例下面渲染了一个列表，点击列表时会显示一些条目信息 html： 1&lt;ul class=\"list-group\"&gt;2 &lt;li class=\"list-item\"&gt;条目一&lt;/li&gt;3 &lt;li class=\"list-item\"&gt;条目二&lt;/li&gt;4 &lt;li class=\"list-item\"&gt;条目三&lt;/li&gt;5&lt;/ul&gt; js： 1let list = document.querySelector('.list-group')2list.addEventListener('click', function(event) &#123;3 let target = event.target //可以获取到实际点击的对象4 console.log(target.innerText)5&#125;) 这样我们无需为每一个条目注册事件，并且后续如果列表发生了变化，新增的条目也能触发事件 使用事件代理的好处 节省内存 减少事件注册 目标节点不需要存在，即事件监听后渲染的元素也同样能触发 事件触发的阶段综上所述，我们可以得出当事件触发时，有三个阶段 最顶层（window）往事件触发处传递，遇到注册的捕获事件会触发 传递到事件触发处时触发注册的事件 事件触发处向最顶层（window）传递，遇到注册的冒泡事件会触发 如果一个节点同时注册了冒泡和捕获事件，则按注册顺序触发 DOM多级事件dom的事件级别含义是根据w3c指定的dom标准区分，按时间先后分为dom级别0、dom级别1、dom级别2、dom级别3，其实各个级别就是不同时间颁发或补充的标准 DOM0级规定了使用形如onclick的方式绑定事件 DOM1级1级DOM标准中并没有规定事件相关的内容 DOM2级新增了事件监听，即addEventListener函数和removeEventListener DOM3级对dom事件的规范和补充，主要是h5新增的拖拽、触摸和视频播放等事件","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"},{"name":"dom","slug":"dom","permalink":"http://blog.c2wei.cn/tags/dom/"}]},{"title":"js闭包","slug":"js闭包","date":"2018-05-15T09:55:05.000Z","updated":"2020-03-06T09:06:51.492Z","comments":true,"path":"2018/05/15/js闭包/","link":"","permalink":"http://blog.c2wei.cn/2018/05/15/js%E9%97%AD%E5%8C%85/","excerpt":"","text":"概念函数与对其状态即词法环境的引用共同构成闭包。 通俗的说，函数A返回了函数B，函数B使用了函数A内声明的变量，那函数B就是一个闭包 1function A() &#123;2 let temp = 13 return function B() &#123;4 console.log(temp)5 &#125;6&#125; 一般来说，函数在弹出执行栈后，其内部变量也将销毁，但是闭包让引用的变量放在了堆上，也称为“逃逸”。 合理的闭包可以有很多用处，但过分使用闭包并不提倡，因为闭包引用的变量无法回收，会造成一定性能浪费。 用处因为闭包可以“保存状态”，因此我们可以解决许多问题，或者在es5中模拟块级作用域 解决循环创建函数的经典问题1var arr = [];2for (var i = 0; i &lt; 3; i ++) &#123;3 arr[i] = function() &#123;4 console.log(i);5 &#125;6&#125;7arr[1]();8arr[2](); 上述代码会输出两个3，因为i泄露为全局变量，函数调用时i已变为3 保存变量状态例如，在定时器实现函数防抖中，用闭包保存定时器 1function debounce(func, wait) &#123;2 let timeout = null3 return function() &#123;4 if (timeout != null) timeout = null5 timeout = setTimeout(func, wait)6 &#125;7&#125; 事件绑定的回调函数带参事件绑定的时候，回调函数只能跟函数名，一旦函数名带括号就会立即执行，因此无法携带参数，往往需要写一个匿名函数(其实也是闭包)，通过闭包可以实现回调函数带参 如在tab切换时修改item的class增加active html: 1ul.tab&gt;li.tab-item*3 js: 1let tabBarList = document.querySelectorAll('.tab-item')2tabBarList.forEach((item, index) =&gt; &#123;3 item.onclick = handle(index)4&#125;)5function handle(newIndex) &#123;6 let currentIndex = 07 return function() &#123;8 tabBarList[currentIndex].setAttribute('class', 'nav-item')9 tabBarList[newIndex]..setAttribute('class', 'nav-item active')10 currentIndex = newIndex11 &#125;12&#125; 性能浪费1.过分使用闭包模拟私有方法： 1function response(status, message, data) &#123;2 this.status = status3 this.message = message4 this.data = data5 this.getStatus = function() &#123;6 return this.status7 &#125;89 this.getMessage = function() &#123;10 return this.message11 &#125;12 13 this.getData = function() &#123;14 return this.data15 &#125;16&#125; 应当改为 1function response(status, message, data) &#123;2 this.status = status3 this.message = message4 this.data = data5&#125;67response.prototype.getStatus = function() &#123;8 return this.status9&#125;1011response.prototype.getMessage = function() &#123;12 return this.message13&#125;14 15response.prototype.getData = function() &#123;16 return this.data17&#125; 2.主动释放变量 下面代码会使得block变量泄露，无法回收，占用内存 1function getIndex() &#123;2 var block = document.getElementById(\"block\")3 block.onclick = function()&#123;4 console.log(block.id)5 &#125;6&#125; 因此可以改成下面 1function showId() &#123;2 var block = document.getElementById(\"block\")3 var id = block.id4 block.onclick = function()&#123;5 console.log(id)6 &#125;7 block = null // 主动释放8&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"}]},{"title":"js防抖与节流","slug":"js防抖与节流","date":"2018-05-12T04:20:18.000Z","updated":"2020-03-06T09:07:11.134Z","comments":true,"path":"2018/05/12/js防抖与节流/","link":"","permalink":"http://blog.c2wei.cn/2018/05/12/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"为什么防抖和节流在使用一些js事件时，比如scroll、mousewheel、resize等，这些事件会频繁的触发，频繁调用回调函数，我们希望控制回调函数触发频率，这需要防抖和节流。 在做搜索推荐或一些秒杀抢购场景中，频繁的输入变化或按钮点击会导致后端API被频繁调用，产生大量请求，这时候也需要防抖和节流。 防抖和节流是什么防抖和节流简单来说就是控制函数被调用的频率： 节流是函数每K秒被调用一次。如scroll事件，不停的滚动屏幕，回调函数每1秒执行一次 防抖是某个连续的用户行为停止或连续触发的事件停止时调用函数，即K秒内用户行为或事件没有发生。如scroll事件，不停的滚动屏幕，滚动过程中不会触发，而当屏幕停止滚动时调用回调函数，判断停止的条件就是1s内屏幕没有滚动 从事件触发角度解释： 节流是事件频繁触发，每K秒执行一次回调函数 防抖是事件频繁触发，在最后一次事件结束K秒后触发事件，如果K秒内再次触发了事件，则重新计时 防抖和节流怎么做用定时器实现一个简单的防抖1function debounce(func, wait) &#123;2 var timeout = null;3 return function() &#123;4 if (timeout != null) clearInterval(timeout);5 timeout = setTimeout(function() &#123;6 func()7 &#125;, wait*1000); 8 &#125;9&#125; 测试 1function handle() &#123;2 console.log(1);3&#125;4window.addEventListener('mousewheel', debounce(handle, 1)); 传递this指针在实现防抖的时候，虽然做到了在最后一次事件K秒后执行回调，但是回调函数的this指针发生了改变，也不能传递参数，因此使用apply()方法修改为 1function debounce(func, wait) &#123;2 var timeout = null;3 return function() &#123;4 if (timeout != null) clearInterval(timeout);5 var that = this;6 var args = arguments;7 timeout = setTimeout(function() &#123;8 func.apply(that, args);9 &#125;, wait*1000); 10 &#125;11&#125; 用定时器实现一个简单的节流1function throttle(func, wait) &#123;2 var timeout = null;3 return function() &#123;4 var that = this;5 var args = arguments;6 if (!timeout) &#123;7 timeout = setTimeout(function() &#123;8 func.apply(that, args);9 timeout = null;10 &#125;, wait*1000);11 &#125;12 &#125;13&#125; 测试 1function handle() &#123;2 console.log(1);3&#125;4window.addEventListener('mousewheel', throttle(handle, 1)); 用时间戳实现一个简单的节流1function throttle(func, wait) &#123;2 var time = Date.now();3 return function() &#123;4 var now = Date.now();5 var that = this;6 var args = arguments;7 if (now - time &gt; wait*1000) &#123;8 func.apply(that, args);9 time = now;10 &#125;11 &#125;12&#125; 执行回调的时间 事件触发时先执行回调一次 最后一次事件触发是否执行回调 回调函数返回的参数","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"}]},{"title":"js作用域","slug":"js作用域","date":"2018-05-05T12:55:01.000Z","updated":"2020-03-06T09:07:02.021Z","comments":true,"path":"2018/05/05/js作用域/","link":"","permalink":"http://blog.c2wei.cn/2018/05/05/js%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"javascript在es5中通过var关键字声明变量，变量作用域只有函数作用域（局部作用域）和全局作用域。es6新增了let和const声明变量，并且新关键字声明的变量具有块作用域。 局部作用域和全局作用域var关键字声明的变量拥有全局作用域和函数作用域，根据声明位置不同拥有不同的作用域 且var关键字声明变量可以重复声明 位于全局作用域的变量(声明语句不位于任一函数中)，在任何地方任一函数中都可以访问到 在函数体中声明的变量拥有函数作用域，只能作用于该函数体，即只在该函数中可以访问到 1var globalVar = 'global'; //全局变量23function func() &#123;4 var localVar = 'local'; //位于func函数的局部变量5 console.log(globalVar); //输出global6 console.log(localVar); //输出local7&#125;8func();910console.log(globalVar); //输出global11console.log(localVar); //报错：localVar没有被定义 变量提升用var关键字声明变量存在变量提升现象，即一个变量可以在它声明前使用它，如下面的代码 1console.log(x)2var x = 1;3function func() &#123;4 console.log(y);5 var y = 2;6&#125; 这是因为js执行时会将每个作用域的变量声明自动提升至该作用域的头部 同时因为var关键字没有块作用域，因此在{}代码块里的变量会直接提升到所属作用域头部，产生变量泄露，比如下面的代码 1console.log(i);2for (var i = 0; i &lt; 3; i ++) &#123;3 // code4&#125; 就近原则js能在函数内定义函数，因此作用域也可以嵌套，外层作用域的变量在内层同样能够访问到，比如下面的代码 1function() &#123;2 var a = 1;3 function() &#123;4 console.log(a);5 function() &#123;6 console.log(a);7 &#125;8 &#125;9&#125; 前面我们提到过变量可以重复声明，当在不同作用域重复声明时，使用变量时会访问到离当前作用域最近的作用域里声明的变量，这被称为就近原则 如下面的代码，输出的是2，因为var a = 2所在作用域离输出语句所在作用域最近 1var a = 1;2function func() &#123;3 var a = 2;4 function func2() &#123;5 console.log(a); //26 &#125;7&#125; 再运行一个例子： 1var a = 1;2function func() &#123;3 var a = 2;4 func2();5&#125;6func();7function func2() &#123;8 console.log(a);9&#125; 可以发现输出的值为1 这是因为虽然func2的执行语句离var a = 2最近，但是作用域的位置是通过函数体定义位置判断，即作用域嵌套与函数执行顺序或时间无关，只与函数定义有关 一个经典问题有一个很经典的有关js作用域的问题，看下面的代码 1var arr = [];2for (var i = 0; i &lt; 3; i ++) &#123;3 arr[i] = function() &#123;4 console.log(i);5 &#125;6&#125;7arr[1]();8arr[2](); 在脑子里运行一下这段代码，感觉输出会是什么？是1 2？ 在电脑上执行一下，结果是3 3，这是为什么？其实原因都在前文中 因为i使用var关键字声明，所以直接泄露为arr同级作用域的变量，循环执行完毕后，i的值变为3，arr里定义了3个相同的匿名函数，它们访问的是同一个变量，都是泄露后的i，因此都输出了3 一句话：i泄露为全局变量，函数执行时i为3所以输出3 下面两段代码是这个问题的其它常见面孔，这个问题前端笔试题常考 1var li = document.getElementsByTagName('li');2for (var i = 0; i &lt; 3; i ++) &#123;3 li.onclick = function() &#123;4 alert(i);5 &#125;6&#125; 1for(var i = 0; i &lt; 5; i ++) &#123;2 setTimeout(function() &#123;3 console.log(i);4 &#125;, 500);5&#125; 立即执行函数函数定义时会产生只作用于函数内的函数作用域，执行时函数内部就形成了一个独立的作用域，这个独立的作用域会保存执行时内部变量的状态 而js可以写匿名函数，如果将匿名函数立即执行，就可以用来”保存状态“ 立即执行的匿名函数被称为立即执行函数（IIFE），写法如下面： 1//双括号写法2(function() &#123;3 //....4&#125;)();5//运算符写法6!function() &#123;7 //....8&#125;() 可以通过立即执行函数的”保存状态“解决上面那个经典问题，直接贴代码： 1var arr = [];2for (var i = 0; i &lt; 3; i ++) &#123;3 !function() &#123;4 var num = i; // 通过一个只作用于该作用域的变量num 记录i当前的值 即保存i的状态5 arr[i] = function() &#123; // 该函数定义位置和num同作用域6 console.log(i);7 &#125;8 &#125;();9&#125;10arr[1]();11arr[2](); 输出结果为1 2 双括号写法： 1var arr = [];2for (var i = 0; i &lt; 3; i ++) &#123;3 (function() &#123;4 var num = i;5 arr[i] = function() &#123;6 console.log(i);7 &#125;8 &#125;)();9&#125; 传参写法： 1var arr = [];2for (var i = 0; i &lt; 3; i ++) &#123;3 (function(num) &#123;4 arr[num] = function() &#123;5 console.log(num);6 &#125;7 &#125;)(i);8&#125; 三种写法效果相同 块作用域js变量提升、变量泄露等问题备受诟病，因此到了es6，js新增了let关键字声明变量和const声明常量 let声明的变量具有块作用域，即只作用于声明变量的{}代码块： 1&#123;2 let var1 = 'block1';3 var var2 = 'block2';4 const var3 = 'block3';5&#125;6console.log(var1) //报错7console.log(var2) //输出值8console.log(var3) //报错 上面那个问题也不再存在，i每一次自增值只作用于对应的{}代码块： 1let arr = [];2for (let i = 0; i &lt; 5; i ++) &#123;3 arr[i] = function() &#123;4 console.log(i);5 &#125;6&#125;7arr[1]();8arr[2](); let声明的变量不存在变量提升，也不会泄露，如下面代码是抛错的 1console.log(block1);2let block1 = 1; let声明的变量不能被重复声明： 1var a = 1;2var a = 1; //正常34let b = 1;5let b = 2; //抛错 const的特性和let一致，但是声明的是常量，不能修改： 1const a = 1;2a = 2; //抛错 因为声明时保存的只是一个引用，所以当const声明的常量为{}对象或[]数组时，常量的内容可以修改，只是引用不能修改： 1const obj = &#123;&#125;;2obj.a = 1; //ok3obj = &#123;&#125;; //抛错","categories":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"}]},{"title":"五、php接收数据和响应数据","slug":"五、php接收数据和响应数据","date":"2018-03-05T12:46:54.000Z","updated":"2020-03-06T01:01:44.833Z","comments":true,"path":"2018/03/05/五、php接收数据和响应数据/","link":"","permalink":"http://blog.c2wei.cn/2018/03/05/%E4%BA%94%E3%80%81php%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%92%8C%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/","excerpt":"","text":"请求处理php对http请求做了完善的处理，毕竟是为web开发而生，通过内置常量就可以轻松的获取到各种信息 get方法数据接收下表为对应函数接收的值 - 查询参数/index.php?id=1&amp;foo=bar 路由参数/index.php/1/bar $_REQUEST 键值对 [‘id’ =&gt; 1, ‘foo’ =&gt; ‘bar’] 空数组 $_GET 键值对 [‘id’ =&gt; 1, ‘foo’ =&gt; ‘bar’] 空数组 $_SERVER[‘QUERY_STRING’] 字符串：id=1&amp;foo=bar 报警：Undefind index $_SERVER[‘REQUEST_URI’] 字符串：/?id=1&amp;foo=bar 字符串：/1/bar $_SERVER[‘SCRIPT_NAME’] 字符串：/index.php 字符串：/Index.php $_SERVER[‘PHP_SELF’] 字符串：/index.php 字符串：/Index.php/1/bar post方法数据接收发送信息为id=1&amp;foo=bar和 {“id”: 1, “foo”: “bar”} - application/x-www-form-urlencoded application/json multipart/form-data $_POST 键值对[‘id’ =&gt; 1, ‘foo’ =&gt; ‘bar’] 空数组 键值对[‘id’ =&gt; 1, ‘foo’ =&gt; ‘bar’] file_get_contents(“php://input”) 字符串：id=1&amp;foo=bar 字符串：{“id”: 1, “foo”: “bar”} 不能使用 $_REQUEST 键值对[‘id’ =&gt; 1, ‘foo’ =&gt; ‘bar’] 空数组 键值对[‘id’ =&gt; 1, ‘foo’ =&gt; ‘bar’] $_FILES 不能传输文件 不能传输文件 有文件时会有文件信息 响应php的响应函数 header(); 设置响应头 1header('Content-type: application/json; charset=UTF-8'); http_response_code(); 设置状态码 1http_response_code(404); Json_encode/json_decode 编码和解析json数据 响应时主要用到编码 1echo json_encode([2 'code' =&gt; 10001,3 'msg' =&gt; \"操作成功\",4 'data' =&gt; []5]);","categories":[{"name":"前后端数据传输","slug":"前后端数据传输","permalink":"http://blog.c2wei.cn/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.c2wei.cn/tags/php/"},{"name":"http","slug":"http","permalink":"http://blog.c2wei.cn/tags/http/"}]},{"title":"四、nodejs接收数据和响应数据","slug":"四、nodejs接收数据和响应数据","date":"2018-03-01T11:10:37.000Z","updated":"2020-03-05T09:59:01.934Z","comments":true,"path":"2018/03/01/四、nodejs接收数据和响应数据/","link":"","permalink":"http://blog.c2wei.cn/2018/03/01/%E5%9B%9B%E3%80%81nodejs%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%92%8C%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/","excerpt":"","text":"一般大而全的高级开发框架都对请求和响应做了封装，因此本文汇总的是原生nodejs及基础框架express的请求和响应 原生1const http = require('http')2const url = require('url')3const queryString = require('querystring')45http.createServer((request, response) =&gt; &#123;6 //控制台输出请求头7 console.log(\"请求头\", request.headers)8 9 //除域名外的url部分 例 http://abc.cn/user/info?id=1会得到 /user/info?id=1 10 console.log(\"url\", request.url)11 12 //解析url13 let urlinfo = url.parse(request.url)14 console.log(\"urlinfo\", urlinfo)15 16 //查询参数 即?id=1&amp;foo=bar 使用queryString解析为object键值对类型17 console.log(\"查询参数\", queryString.parse(urlinfo.query))18 19 //请求类型 GET POST PUT 等20 console.log(\"请求类型\", request.method)21 22 //接受请求体23 let requestBody = ''24 //监听data事件 有数据过来时拼接到requestBody25 //http请求体不是一次接受完的 即使是在同一次请求26 request.on('data', chunk =&gt; &#123;27 requestBody += chunk28 &#125;)29 //请求体接受完成时30 request.on('end', () =&gt; &#123;31 //将输出原始编码格式 格式参考第一节内容32 console.log(\"请求体原始内容\", requestBody)33 34 //处理原始格式35 let contentType = request.headers['content-type']36 if (!contentType) return37 // 一 x-www-form-urlencoded38 if (contentType.indexOf('application/x-www-form-urlencoded') &gt; -1) &#123;39 // 解码URL encoding40 requestBody = decodeURI(requestBody)41 // 借助queryString解析为object键值对类型 因为也是id=1&amp;foo=bar的格式42 console.log(\"处理后的请求体\", queryString.parse(requestBody))43 &#125;44 // 二 application/json45 else if (contentType.indexOf('application/json') &gt; -1) &#123;46 // json类型直接解析47 console.log(\"处理后的请求体\", JSON.parse(requestBody))48 &#125;49 // 三 multipart/form-data50 else if (contentType.indexOf('multipart/form-data') &gt; -1) &#123;51 //建议使用框架 express koa 等52 &#125;5354 else &#123;55 console.log(\"不能识别的请求头\")56 &#125;57 58 &#125;)59 //设置响应内容主体60 let result = &#123;61 code: 10001,62 msg: \"操作成功\",63 data: []64 &#125;65 //设置响应头66 let headers = &#123;67 \"Access-Control-Allow-Origin\": \"*\",68 \"Access-Control-Allow-Credentials\": \"true\",69 \"Access-Control-Allow-Methods\": \"POST, GET, PATCH, DELETE, PUT\",70 \"Access-Control-Max-Age\": \"3600\",71 \"Access-Control-Allow-Headers\": \"Content-Type, Content-Length, Authorization, Accept, X-Requested-With, yourHeaderFeild\",72 'Content-type': 'text/json; charset=UTF-8'73 &#125;74 response.writeHead(200, headers)75 response.write(JSON.stringify(result))76 response.end()77&#125;).listen(8888) express请求get方法1&#x2F;&#x2F;使用查询参数时无需调整url格式2app.get(&#39;&#x2F;test&#39;, (req, res) &#x3D;&gt; &#123;3 console.log(params, req.params)4 console.log(query, req.query)5 res.json(&#123;6 text: &#39;hello world&#39;7 &#125;)8&#125;)9&#x2F;&#x2F;使用路由参数时需要定义路由参数匹配规则10app.get(&#39;&#x2F;test&#x2F;:id&#x2F;:foo&#39;, (req, res) &#x3D;&gt; &#123; &#x2F;&#x2F;或&#39;&#x2F;test&#x2F;id&#x2F;:id&#x2F;foo&#x2F;:foo&#39; 获取到的参数信息一致11 console.log(params, req.params)12 console.log(query, req.query)13 res.json(&#123;14 text: &#39;hello world&#39;15 &#125;)16&#125;) 获取方式对照 查询参数 /test?id=1&amp;foo=bar 路由参数 /test/1/bar或/test/id/1/foo/bar req.params {} {id: 1, foo: “bar”} req.query {id: 1, foo: “bar”} {} $.get方法和$.ajax({type:’get’})设置的data为查询参数 路由参数需要自行拼接字符串 axios.get(url, {params: data})设置的data为查询参数、相应的在axios({method: ‘get’, params: {}})中的params参数为查询参数，路由参数可以拼接字符串或者使用axios配置的paramsSerializer参数(系列化函数) post方法express解析http协议的请求体需要另外安装中间件 body-parser可以解析urlencoded和json，使用npm安装 1npm i body-parser -S 解析对应Content-type的数据： application/x-www-form-urlencoded 1//全局请求2const bodyParser = require('body-parser')3app.use(bodyParser.urlencoded(&#123;extended: false&#125;))45//部分请求6const bodyParser = require('body-parser')7const urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;)8app.post('/post', urlencodedParser, async (req, res) =&gt; &#123;9 let data = req.body10 res.json(&#123;11 \"请求body\": data12 &#125;)13&#125;) application/json 1//全局2const bodyParser = require('body-parser')3app.use(bodyParser.json())4//部分请求5const bodyParser = require('body-parser')6const jsonParser = bodyParser.json()7app.post('/postjson', jsonParser, async (req, res) =&gt; &#123;8 let data = req.body9 res.json(&#123;10 \"请求body\": data11 &#125;)12&#125;) multipart/form-data 解析multipart/form-data格式需要multer中间件，当处理文件上传时，才能使用此格式 使用npm安装 1npm install multr -S 引入并使用 1const express = require('express')2const app = express()3const multer = require('multer')4// 配置文件上传目录5let upload = multer(&#123;dest: 'uploads/'&#125;)6// 单文件上传时7app.post('/upload', upload.single('file'), (req, res) =&gt; &#123;8 console.log('body', req.body)9 console.log('file', req.file) //获取文件信息10 res.json(&#123;11 \"请求body\": req.body12 &#125;)13&#125;)14// 多文件上传15let count = 5 //文件数量16app.post('/uploads', upload.array('files', count), (req, res) =&gt; &#123;17 console.log('body', req.body)18 console.log('files', req.files) //获取文件信息19 res.json(&#123;20 \"请求body\": req.body21 &#125;)22&#125;) 响应1const express = require('express')2const app = express()34app.get('/user', (req, res) =&gt; &#123;5 let result = &#123;6 code: 10001,7 msg: \"操作成功\",8 data: []9 &#125;10 res.status(200)11 res.set(&#123;'Content-type': 'application/json; charset=UTF-8'&#125;)12 res.send(JSON.stringify(result))13&#125;)1415app.get('/index', (req, res) =&gt; &#123;16 let result = &#123;17 code: 10001,18 msg: \"操作成功\",19 data: []20 &#125;21 // res对象提供了json方法直接响应json数据22 res.json(result)23&#125;) Koa…本部分不完整 请求get 使用request.query获取原始查询参数字符串 使用request.querystring获取解析后的查询参数 postkoa类似express，也是依赖中间件解析http request body body-paser 1var Koa = require('koa');2var bodyParser = require('koa-bodyparser');34var app = new Koa();5app.use(bodyParser());67app.use(async ctx =&gt; &#123;8 ctx.body = ctx.request.body;9&#125;);1011app.listen(3000); json 1const body = require('koa-json-body')23app.use(body(&#123; limit: '10kb', fallback: true &#125;))45app.use((ctx, next) =&gt; &#123;6 console.log(ctx.request.body)7&#125;) multer 1const Koa = require('koa');2const route = require('koa-route');3const multer = require('koa-multer');45const app = new Koa();6const upload = multer(&#123; dest: 'uploads/' &#125;);78app.use(route.post('/upload', upload.single('avatar')));910app.listen(3000);","categories":[{"name":"前后端数据传输","slug":"前后端数据传输","permalink":"http://blog.c2wei.cn/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.c2wei.cn/tags/nodejs/"},{"name":"express","slug":"express","permalink":"http://blog.c2wei.cn/tags/express/"}]},{"title":"三、后端响应数据的格式","slug":"三、后端响应数据的格式","date":"2018-02-28T10:40:07.000Z","updated":"2020-03-06T03:20:14.052Z","comments":true,"path":"2018/02/28/三、后端响应数据的格式/","link":"","permalink":"http://blog.c2wei.cn/2018/02/28/%E4%B8%89%E3%80%81%E5%90%8E%E7%AB%AF%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"概述在前后端分离开发中，前端请求api接口，后端需要输出响应的数据。现在http响应体数据一般使用json格式，虽然以前还有xml格式，但xml格式在web接口响应中已经逐渐淡出。 使用json格式也有一定的规范，具体的规范和格式在实际项目中由前后端共同约定，基本要做到几个要求：响应模板结构统一、数据结构统一和清晰可查的返回码和返回消息等，返回码和返回消息这部分中特别是错误信息极为重要，因为接口不是给用户看的，是给开发人员和程序看的。 http响应报文http响应报文由响应行（http版本 http状态码 http状态消息）、响应头和响应体三部分。 响应体是后端实际输出的部分，往往包含返回码、返回消息和返回数据。这里的返回码和http状态码不要搞混了，http状态码是这个http请求的状态信息，标志着请求本身的结果，而返回码则是应用层面的状态信息，标志着请求数据的结果。用登录接口举个例子，如果我们提交了错误的密码，这时http请求能够成功的，但登录不会成功，所以http状态码是成功码，但是返回码就是失败码（即密码错误），报文如下： 1HTTP/1.1 200 OK //响应行2Date: Sun, 17 Mar 2017 08:12:54 GMT //响应头部3Server: Apache/2.2.8 (Win32) PHP/5.2.54Content-Length: 43935Content-Type: text/json; charset=utf-86 // 空行（必需）7&#123;8 \"code\": 10002,9 \"message\": \"密码错误\",10 \"data\": []11&#125; http状态码的使用方式在接口中的设计差异很大，有的应用只用http状态码来表示http请求结果，与应用层面无关；而有的应用会把http状态码也用在应用层面，比如刚才说的登录接口例子，密码错误时http状态码也设置为错误码；还有的应用会做更个性化的设计，就不详细说了，但不管怎么设计，都要满足需要，核心就是http响应报文和响应体的格式。 响应体数据响应体数据格式一般按照一个统一模板。一个合格的响应模板，要有返回码、返回消息和返回数据 常见的模板如下 1&#123;2 \"code\": 10001,3 \"msg\": \"登录成功\",4 \"data\": &#123;5 \"token\": \"...\",6 \"userinfo\": [\"...\"],7 \"permission\": [\"...\"]8 &#125;9&#125; 具体的字段根据应用设置，有的应用返回消息字段会分为err和msg（或是error和message），用来区别成功消息和错误消息，有的应用会只用msg（或message）一个字段，通过http状态码或返回码来区分信息是错误消息还是成功消息。 http状态码http状态码标志请求的状态，也可以映射到应用状态，按照开头数字不同分为五个大类 1xx 信息通知，如101-切换协议 2xx 成功，如200-成功 201-资源已创建 3xx 重定向，如301-请求地址已永久移动 4xx 用户行为错误，如404-请求或资源不存在 401-未认证 5xx 服务端（应用）错误，如500-服务器内部错误 502-网关错误 以下是(我)常用的几个 200 ok 请求成功 400 Bad Request 错误的请求 401 unauthorized 未认证 403 forbidden 访问禁止，比如权限不足 422 “unprocessable entity” 参数错误 500 intenal server error 服务器内部错误 http响应头在响应头中可以设置cookie、缓存等信息，规定响应体的格式告诉浏览器返回数据格式，还可以设置自定义响应头来刷新token 1Content-Type: text&#x2F;json; charset&#x3D;utf-82Refresh-token: .... 返回码和消息返回码和返回消息需要根据项目业务来具体设计，实际开发中往往独自定义到一个文件，或是一个类，并且配合异常捕获一起使用 一定要清晰的表明成功和错误信息，下面是微信公众号开发的全局返回码的部分截取","categories":[{"name":"前后端数据传输","slug":"前后端数据传输","permalink":"http://blog.c2wei.cn/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"}],"tags":[{"name":"http","slug":"http","permalink":"http://blog.c2wei.cn/tags/http/"}]},{"title":"二、Ajax发送数据","slug":"二、Ajax发送数据","date":"2018-02-27T01:27:23.000Z","updated":"2020-03-05T09:45:00.483Z","comments":true,"path":"2018/02/27/二、Ajax发送数据/","link":"","permalink":"http://blog.c2wei.cn/2018/02/27/%E4%BA%8C%E3%80%81Ajax%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/","excerpt":"","text":"浏览器发送ajax请求通过XMLHttpRequest对象实现（简称xhr），在实际开发中一般使用第三方库，常用的请求库有jquery的$.ajax和axios，以后也势必是axios的天下，毕竟axios是vue和react的标准请求库了 传统表单提交浏览器表单提交，即浏览器的get/post请求，会产生页面跳转，一般不使用 get 1&lt;form action=\"/index.php\" method=\"get\"&gt;2 &lt;input name=\"id\" type=\"text\" value=\"1\" /&gt;3 &lt;input name=\"foo\" type=\"text\" value=\"bar\" /&gt;4 &lt;input id=\"submit\" type=\"submit\" value=\"go\"/&gt;5&lt;/form&gt; post 1&lt;form enctype=\"multipart/form-data\" action=\"/index.php\" method=\"post\"&gt;2 &lt;input name=\"id\" type=\"text\" value=\"1\" /&gt;3 &lt;input name=\"foo\" type=\"text\" value=\"bar\" /&gt;4 &lt;input name=\"file\" type=\"file\" /&gt;5 &lt;input id=\"submit\" type=\"submit\" value=\"go\"/&gt;6&lt;/form&gt; 表单的enctype属性默认为application/x-www-form-urlencoded，当有type=file的input时必须设置为multipart/form-data，因为此Content-Type才支持文件传输 js原生xhr对象1let url = '/index.php'2let id = 1, str = 'bar'3const xhr = new XMLHttpRequest()4xhr.open('GET', url, true) //第三个参数为是否异步5xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')6xhr.onreadystatechange = () =&gt; &#123;7 if (xhr.readyState === 4) &#123;8 console.log(xhr.status, xhr.statusText)9 console.log(xhr.response)10 let myHeader = xhr.getResponseHeader('MyHeader')11 let allHeader = xhr.getAllResponseHeaders()12 &#125;13&#125;14xhr.send(`id=$&#123;id&#125;&amp;foo=$&#123;str&#125;`) js表单对象1let formData = new FormData()2formData.append('id', '1')3formData.append('foo', 'bar')45//使用xhr发送 formData默认是multipart/form-data格式 主要用于ajax发送文件6xhr.send(formData) $.ajax发送： 1$.ajax(&#123;2 url: '/hello',3 type: 'get', //默认为get,4 data: &#123;&#125;,5// 下面是一种鉴权方式 后面会讨论 此处展示下headers的作用6 headers: &#123;'Authorization': 'Bearer ' + token&#125;,7 contentType: 'application/x-www-form-urlencoded', //默认为application/x-www-form-urlencoded8 context: &#123;&#125;, // 为回调函数指定this 可以不指定9// 以下xhr为本请求的XMLHttpRequest对象 10// status表示请求状态 值为success或error 没什么卵用11// 使用xhr.status 和 xhr.statusText可以得到http状态码和对应信息12 success: function(response, status, xhr) &#123;&#125;, //请求成功时的回调 response包含了响应信息13 error: function(xhr, status, error) &#123;&#125;, //请求错误时的回调 通过xhr.response依旧可以得到响应信息14 complete: function(xhr, status) &#123;&#125; //请求结束时的回调 在success和error之后15&#125;) $.ajax没有对服务端响应数据进行包装，只会进行json处理，字符串仍为字符串形式 jquery提供了$.get()和$.post别名方法，在简单场景下配置方便，但是可配置性较差 1$.get(url, data, function(data, status, xhr), dataType) 2$.post(url, data, function(data, status, xhr), dataType) 3// data为&#123;&#125;格式 除url参数外均为可选 axios 写法 1axios(&#123;2 url: 'hello',3 method: 'post', // 默认是 get4 // 自动和url拼接，注意url以'/'开头或为完整url时无效5 baseURL: 'http://127.0.0.1：7000/',6 7 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;,8 // 查询参数querystring9 params: &#123;10 ID: 1234511 &#125;,12 // 查询参数系列化13 paramsSerializer: function(params) &#123;14 return Qs.stringify(params)15 &#125;,16 // 请求主体 也可以设置字符串 如 data: \"id=1&amp;foo=bar\"17 data: &#123;18 id: 1,19 foo: 'bar'20 &#125;,21 // 超时时间，单位ms22 timeout: 1000023&#125;)24.then(response =&gt; &#123;25 //查看服务器响应信息26 console.log(response)27&#125;)28.catch(error =&gt; &#123;29 //错误时服务器响应信息在 error.response中 格式和请求成功的response一致30 console.log(error.response)31&#125;) data数据格式 axios会根据data参数格式的不同，自动设置请求头里的Content-Type，具体如下 数据格式 Content-Type “id=1&amp;foo=bar” application/x-www-form-urlencoded {id: 1, foo: “bar”} application/json js表单对象new FormData() multipart/form-data 这里要注意，服务端对不同格式的接收方法有所不同，后面会展开说明 别名写法 axios提供了axios.method()形式的一系列别名写法，类似jquery的别名写法，但是多了一个可选的config参数可以配置请求信息 1axios.get(url, &#123;params: data&#125;, config)2.then(response =&gt; &#123;&#125;)3.catch(error =&gt; &#123;&#125;)45axios.get(url, data)6.then(response =&gt; &#123;&#125;)7.catch(error =&gt; &#123;&#125;) 响应数据 axios对响应数据进行了包装 axios的响应格式，即.then的回调函数的参数response： 1&#123;2 // 响应主体3 data: &#123;&#125;,4 // http状态码5 status: 200,6 // http状态信息7 statusText: 'OK',8 // 响应头9 headers: &#123;&#125;10 11 ...12&#125; ajax上传文件前面说过了js表单对象FormData，使用此对象可以实现文件的异步上传 html: 1&lt;input id=\"file\" name=\"file\" type=\"file\" multiple=\"multiple\"&gt;2&lt;button id=\"submit\"&gt;上传&lt;/button&gt; Js: 1let file = document.querySelector('#file')2let submit = document.querySelector('#submit')3file.onchange = function() &#123;4 console.log(this.files)5&#125;6submit.onclick = function() &#123;7 let formData = new FormData()8 console.log(file.files)9 form.append('file', file.files[0])10 form.append('foo', 'bar') //添加一些额外信息11 let url = '/upload'12 upload(url, formData) //upload函数额外实现13&#125; upload函数 1//原生xhr2function upload(url, formData) &#123;3 const xhr = new XMLHttpRequest()4 xhr.open('POST', url, true)5 // 一定不要手动设置请求头Content-type为multipart/form-data6 xhr.onreadystatechange = () =&gt; &#123;7 if (xhr.readyState === 4) &#123;8 console.log(xhr.status, xhr.statusText)9 console.log(xhr.response)10 &#125;11 &#125;12 xhr.send(formData)13&#125;14//$.ajax15function upload(url, formData) &#123;16 $.ajax(&#123;17 url: url,18 type: 'post',19 data: formData,20 processData: false,21 contentType: false, //会自动设置为multipart/form-data 不要手动添加22 success: function(res, status, xhr) &#123;23 console.log(res)24 console.log(xhr.status, xhr.statusText)25 console.log(xhr.response)26 &#125;,27 error: function(xhr, status, error) &#123;28 console.log(xhr.status, xhr.statusText)29 console.log(xhr.response)30 &#125;31 &#125;)32&#125;33//axios 请求头会自动设置34function upload(url, formData) &#123;35 axios(&#123;36 url: url,37 method: 'post',38 data: formData39 &#125;)40 .then(response =&gt; &#123;41 console.log(response)42 &#125;)43 .catch(error =&gt; &#123;&#125;)44&#125; 关于为什么一定不要手动设置请求头Content-type为multipart/form-data，因为multer编码产生一个boundary值，这个值会放在请求头中，手动设置会覆盖掉boundary值，造成请求失败","categories":[{"name":"前后端数据传输","slug":"前后端数据传输","permalink":"http://blog.c2wei.cn/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"},{"name":"http","slug":"http","permalink":"http://blog.c2wei.cn/tags/http/"},{"name":"前端","slug":"前端","permalink":"http://blog.c2wei.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"一、http发送数据的格式","slug":"一、http发送数据的格式","date":"2018-02-26T07:04:14.000Z","updated":"2020-03-05T09:34:26.429Z","comments":true,"path":"2018/02/26/一、http发送数据的格式/","link":"","permalink":"http://blog.c2wei.cn/2018/02/26/%E4%B8%80%E3%80%81http%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"HTTP请求的组成http请求有四部分组成，即请求行、请求头、空行、请求体，例： 1POST /post HTTP/1.1 #请求行2Accept: application/json, text/plain, */* #从这行开始为请求头 3Accept-Encoding: gzip, deflate, br4Accept-Language: zh-CN,zh;q=0.9,en;q=0.85Connection: keep-alive6Content-Length: 227Content-Type: application/x-www-form-urlencoded; charset=UTF-88Host: 127.0.0.1:70029Origin: http://127.0.0.1:700010User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.3611 #空行 但是必需12id=1&amp;foo=bar #请求(主)体 get请求的参数get请求的作用通常是向服务端获取信息，即”查询“，查询往往需要有条件的查询，因此get请求会带有一些参数， 这些参数根据发送格式分为查询参数和路由参数两类 如下发送的都是 {id: 1, name: &quot;quz&quot;} 数据 查询参数(queryString) 格式：?id=1&amp;name=quz 例：http://abc.cn/api/user?id=1&amp;name=quz 路由参数 格式：/api/user/1/quz 或 /api/user/id/1/name/quz 例：http://abc.cn/api/user/1/quz 或 http://abc.cn/api/user/id/1/name/quz 两种格式的参数服务端接收时略有不同，后边会展开讨论 get请求的参数通常附带在url中，都比较简短，一些应用中在使用post请求也会把条件参数放在url中，但是只要是url里的参数，使用最多的格式就这两种 post请求的请求体post请求（包括put请求）会向服务端发送一些实体数据用于保存或更新操作，这部分数据不会在url中，会放在http请求的第四部分请求体中，常用的格式有三种，下面是请求调试工具postman的数据格式部分截图 image-20200209120528557 从postman中可以看到有四种格式，第四种binary使用少一些，暂不讨论，其它三种我结合请求头里的Content-Type进行介绍 form-data这个格式发送的数据在Chrome DevTools(按F12打开的东西)里的截图如下 对应的请求头Content-Type为multipart/form-data，此格式可以发送文件，表单数据会被编码为一条信息，具体格式为 1------WebKitFormBoundaryjW5nW1BH7beKGqTx2Content-Disposition: form-data; name&#x3D;&quot;id&quot;3415------WebKitFormBoundaryjW5nW1BH7beKGqTx6Content-Disposition: form-data; name&#x3D;&quot;foo&quot;78bar9------WebKitFormBoundaryjW5nW1BH7beKGqTx-- 其中数据中每段开头会有一行------WebKitFormBoundaryjW5nW1BH7beKGqTx，这是multer编码的Boundary值，会加在请求头的Content-Type中，因此该格式完整Content-type格式为multipart/form-data; boundary=----WebKitFormBoundaryW5nW1BH7beKGqTx，每次请求的Boundary值也不相同 x-www-form-urlencoded这个格式的数据在Chrome DevTools截图和上一个格式数据一样 对应的请求头Content-Type为application/x-www-form-urlencoded，数据在后端的接收方式通常也和multipart/form-data一致，但是此格式只能发送文本，数据会被编码为键值对，汉字也会被编码，具体格式为 1id&#x3D;1&amp;foo&#x3D;bar 下面是带有汉字时：id=1&amp;foo=测试的编码，汉字编码为URL encoding 1id&#x3D;1&amp;foo&#x3D;%E6%B5%8B%E8%AF%95 raw这个格式发送的数据在Chrome DevTools(按F12打开的东西)里的截图如下 可以看到标题部分已经变为了request payload，但不管是Form Data还是request payload，数据都放在http请求的第四部分请求体中，只是编码/格式的区别 此格式对应的请求头Content-Type为application/json，相对应的数据格式也是json 1&#123;id: 1, foo: &quot;bar&quot;&#125; raw格式和前两种在服务端接受时大有不同，这是前后端必需的沟通点，许多nodejs初学者(包括我)往往碰到post数据为空的情况，就是遇到了这个问题 当不发送文件时使用x-www-form-urlencoded或json格式，只有发送文件时，才使用multipart/form-data","categories":[{"name":"前后端数据传输","slug":"前后端数据传输","permalink":"http://blog.c2wei.cn/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"}],"tags":[{"name":"http","slug":"http","permalink":"http://blog.c2wei.cn/tags/http/"}]},{"title":"用css3写一个翻牌动效","slug":"用css3写一个翻牌动效","date":"2017-12-25T12:50:57.000Z","updated":"2020-03-11T08:59:46.284Z","comments":true,"path":"2017/12/25/用css3写一个翻牌动效/","link":"","permalink":"http://blog.c2wei.cn/2017/12/25/%E7%94%A8css3%E5%86%99%E4%B8%80%E4%B8%AA%E7%BF%BB%E7%89%8C%E5%8A%A8%E6%95%88/","excerpt":"","text":"今天圣诞节，社团推了个圣诞活动小页面，翻卡抽奖送平安果的一个小活动，这里记录一下翻牌动效的实现，用的是css3的transition和transform: rotateY(&#39;angel&#39;)两个属性 html首先写一张卡牌，它有外廓和正反面 1&lt;div class=\"card\"&gt;2 &lt;div class=\"card-front\"&gt;&lt;/div&gt;3 &lt;div class=\"card-back\"&gt;&lt;/div&gt;4&lt;/div&gt; css然后写一下基本样式，用绝对定位让正反面重叠在一起 1.card &#123;2 position: relative;3 width: 300px;4 height: 500px;5&#125;6.card-front,7.card-back &#123;8 position: absolute;9 width: 100%;10 height: 100%;11&#125; 因为要实现翻牌效果，所以先将反面旋转180度实现后转，并且给正反面都设置backface-visibility: hidden;该属性会使元素背面向前时隐藏 1.card &#123;2 position: relative;3 width: 300px;4 height: 500px;5&#125;6.card-front,7.card-back &#123;8 position: absolute;9 width: 100%;10 height: 100%;11 transition: all 1s ease;12 backface-visibility: hidden;13&#125;14.card-front &#123;15 background-color: yellow;16 transform: rotateY(0);17&#125;18.card-back &#123;19 background-color: red;20 /* 旋转180度 */21 transform: rotateY(180deg);22&#125; js之后只需要在点击卡片时，分别修改正反面的旋转角度即可 1var card = document.querySelector('.card')2var cardFront = document.querySelector('.card-front')3var cardBack = document.querySelector('.card-back')45var isFront = true6card.addEventListener('click', function() &#123;7 isFront = !isFront8 if (isFront) &#123;9 cardFront.style.transform = `rotateY(0)`10 cardBack.style.transform = `rotateY(180deg)`11 &#125; else &#123;12 cardFront.style.transform = `rotateY(180deg)`13 cardBack.style.transform = `rotateY(0)`14 &#125;15&#125;) 效果预览：http://d.c2wei.cn/animation/css/card-reserve.html","categories":[],"tags":[{"name":"css3","slug":"css3","permalink":"http://blog.c2wei.cn/tags/css3/"}]},{"title":"input的光标","slug":"input的光标","date":"2017-07-30T09:03:07.000Z","updated":"2020-03-10T00:38:56.885Z","comments":true,"path":"2017/07/30/input的光标/","link":"","permalink":"http://blog.c2wei.cn/2017/07/30/input%E7%9A%84%E5%85%89%E6%A0%87/","excerpt":"","text":"隐藏光标1&lt;input name&#x3D;&quot;text&quot; text&#x3D;&quot;text&quot;&gt; 今天有个小需求，要让输入框没有光标，找了找好像没相关的属性，这怎么整？ 冥思苦想下，光标颜色是跟随输入框文字颜色的，所以css里设置文字颜色透明 1&lt;style&gt;2input &#123;3 color: transparent;4&#125;5&lt;/style&gt; 光标果然没有了，可是现在文字也没有了，不要慌，给文字设置一个text-shadow 1&lt;style&gt;2input &#123;3 color: transparent;4 text-shadow: 0 0 0 #000;5&#125;6&lt;/style&gt; 字又出来了，这样一来，光标就被”隐藏“了 移动光标移动到最前或最后1&lt;input type=\"text\" value=\"这里有一行文字\"&gt;2&lt;button&gt;点击&lt;/button&gt; 输入框聚焦后再赋值可以移动到最后，即 1let input = document.querySelector('input')2let button = document.querySelector('button')3button.addEventListener('click', () =&gt; &#123;4 let value = input.value5 input.value = \"\"6 input.focus()7 input.value = value 8&#125;) 同理可得，赋值后再聚焦可以移动到最前 1let input = document.querySelector('input')2let button = document.querySelector('button')3button.addEventListener('click', () =&gt; &#123;4 input.value = input.value5 input.focus()6&#125;) 不过通常情况下，js使用聚焦事件时光标会默认在最前面，用户点击时光标会出现在点击位置。 移动光标到指定位置1&lt;input type=\"text\" value=\"这里有一行文字\"&gt;2&lt;button&gt;点击&lt;/button&gt; 控制字符选中input元素有两个属性，selectionStart和selectionEnd分别控制文字选中的开始位置和结束位置，如下面代码，会选中下标为1到5的字符（起始下标为0） 1let input = document.querySelector('input')2let button = document.querySelector('button')3button.addEventListener('click', () =&gt; &#123;4 input.focus()5 input.selectionStart = 16 input.selectionEnd = 57&#125;) 移动光标设置起始位置和结束位置相同，如都设置为2时，则会选中下标为2到2的字符，即0个字符，就实现了移动光标到下标为2的字符前（起始下标为0） 1let input = document.querySelector('input')2let button = document.querySelector('button')3button.addEventListener('click', () =&gt; &#123;4 input.focus()5 input.selectionStart = 26 input.selectionEnd = 27&#125;) js提供了一个函数，setSelectionRange来控制字符的选中，有三个参数，起始下标、结束下标和选择方向 1input.setSelectionRange(2, 3, &#39;forward&#39;) 使用时和设置selectionStart、selectionEnd属性效果相同 setSelectionRange函数的第三个参数ie系列不支持，并且该函数ie10才开始支持，但ie实现了更强大(复杂)的光标操作 IE浏览器光标操作我没有ie浏览器，暂时也不需要适配，所以以下摘自https://www.cnblogs.com/cheerfulCoder/p/4323930.html 用到的函数 1createTextRange()、 document.selection.createRange()2moveStart() 、moveEnd() 、move() 、collapse() 、text 、select() 详细介绍 createTextRange 1var range &#x3D; input.createTextRange(); &#x2F;&#x2F;创建一个文本选区对象 这个选区对象默认包含了input的全部文本内容。需要注意的是，这个选区对象是一个抽象的区域。，在调用range.select()方法之前，选区对象的内容并不会被添加选中效果。 1range.select(); &#x2F;&#x2F;将选区对象包含的内容选中。 我们可以用 range.text属性得到选区包含的文字 moveStart、moveEnd 选区有两个类似于其他浏览器中selectionStart和selectionEnd属性的方法， moveStart和moveEnd。 默认这个选区对象包含input的全部文本内容，所以它的左右边界分别就是文本的开头和结尾位置。 moveStart方法用来移动左边界。 像这样调用 1range.moveStart(\"character\",2); //左边界右移两个字符 。 character--字符2range.select(); //将range包含的区域选中。 结果 moveStart和moveEnd都要传入两个参数，第一个参数可选值有 character、word、sentence、textedit. 这里我们只用到character，即根据字符来偏移。 第二个参数代表偏移的多少，正负表示方向。 我们知道左边界最初默认是0，右边界默认是文本内容长度值。 我们注意到每次选中range包含区域文本的操作都需要调用range.select()方法，通过select方法来把range对象包含的内容区域选中。这与上面的其他浏览器的实现方式貌似有了大的差异，相比之下似乎并没有那么方便。但是创建一个包含抽象文字区域的选区对象其实提供了更大的灵活性。 我们甚至于可以创建多个选区对象。 collapse 还有一个很有用的方法 collapse， 见名知意，就是将选区对象的范围压缩，下面详细介绍。 collapse可以传入一个布尔值作为参数,参数默认值为true，指示向左还是向右压缩。 1var range = input.createTextRange(); //创建选区对象2//此时选区对象的左边界为0,右边界为input.value.length;3range.collapse();4//此时选区对象左边界为0，右边界为0； 相当于将选区向左收缩了,即使右边界下标等于左边界下标。5range.select(); //左右边界重合,可以显示光标。 效果如图： collapse(true)相当于让右边界下标等于左边界下标。 再试看看collapse(false） 1var range = input.createTextRange(); //创建选区对象2//此时选区对象的左边界为0,右边界为input.value.length;3range.collapse(false);4//此时选区对象左边界为input.value.length，右边界为input.value.length； 相当于将选区向右收缩了,即使左边界下标等于右边界下标。5//左右边界重合,可以显示光标。6range.select(); 效果如图 可以看到，我们使用collapse(false)结合select方法可以很方便的把光标focus到文本框的末尾。 move 还有一个move方法 1var range = input.createTextRange(); 2range.moveStart(\"character\",2); 3range.select(); //图一45range.move(\"character\",3);6//等价于 range.collpase(true); range.moveStart(\"character\",3);range.moveEnd(\"character\",3); 三步。合一7range.select(); //图二 这个方法和moveStart有一样的参数，不过有点难以理解。 上面的代码相当于——先将选区向左收缩，这时候就相当于一个光标咯，然后将光标右移三个字符。 上面的代码的两个图 图一 图二 当我们要移动光标时，move函数必然是一个非常不错的选择。 document.selection.createRange() 这个方法根据当前页面中的选中文字区域来创建一个选区对象，这个选区对象与createTextRange方法的到选区对象的区别在于，它的选区范围为页面选中文字的区域，即它的左右边界不再是默认的左最小右最大。 通过这个方法我们可以轻松获取光标在输入框中的位置。 首先你得理解咯光标和选区的关系。 1var range = document.selection.createRange(); //根据页面中选中区域创建选区对象。 光标也是特殊的选区2range.moveStart(\"character\",-elem.value.length); //移动左边界到03var cursorIndex = range.text.length; //选区对象包含文本长度即光标位置 封装好的函数getCursorKey() , setCursorKey() , getSelection(),setSelection(). 1function getCursor(elem) &#123;2 //IE 9 ，10，其他浏览器3 if (elem.selectionStart !== undefined) &#123;4 return elem.selectionStart;5 &#125; else &#123; //IE 6,7,86 var range = document.selection.createRange();7 range.moveStart(\"character\", -elem.value.length);8 var len = range.text.length;9 return len;10 &#125;11&#125;1213function setCursor(elem, index) &#123;14 //IE 9 ，10，其他浏览器15 if (elem.selectionStart !== undefined) &#123;16 elem.selectionStart = index;17 elem.selectionEnd = index;18 &#125; else &#123; //IE 6,7,819 var range = elem.createTextRange();20 range.moveStart(\"character\", -elem.value.length); //左边界移动到起点21 range.move(\"character\", index); //光标放到index位置22 range.select();23 &#125;24&#125;2526function getSelection(elem) &#123;27 //IE 9 ，10，其他浏览器28 if (elem.selectionStart !== undefined) &#123;29 return elem.value.substring(elem.selectionStart, elem.selectionEnd);30 &#125; else &#123; //IE 6,7,831 var range = document.selection.createRange();32 return range.text;33 &#125;34&#125;3536function setSelection(elem, leftIndex, rightIndex) &#123;37 if (elem.selectionStart !== undefined) &#123; //IE 9 ，10，其他浏览器38 elem.selectionStart = leftIndex;39 elem.selectionEnd = rightIndex;40 &#125; else &#123; //IE 6,7,841 var range = elem.createTextRange();42 range.move(\"character\", -elem.value.length); //光标移到0位置。43 //这里一定是先moveEnd再moveStart44 //因为如果设置了左边界大于了右边界，那么浏览器会自动让右边界等于左边界。45 range.moveEnd(\"character\", rightIndex);46 range.moveStart(\"character\", leftIndex);47 range.select();48 &#125;49&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"},{"name":"html","slug":"html","permalink":"http://blog.c2wei.cn/tags/html/"},{"name":"css","slug":"css","permalink":"http://blog.c2wei.cn/tags/css/"}]},{"title":"js监听输入框值变化","slug":"js监听输入框值变化","date":"2017-07-25T13:41:59.000Z","updated":"2020-03-10T00:38:47.732Z","comments":true,"path":"2017/07/25/js监听输入框值变化/","link":"","permalink":"http://blog.c2wei.cn/2017/07/25/js%E7%9B%91%E5%90%AC%E8%BE%93%E5%85%A5%E6%A1%86%E5%80%BC%E5%8F%98%E5%8C%96/","excerpt":"","text":"事件js监听输入框值或表单输入变化，可以使用的事件有onchange、onpropertychange、oninput。 其中onchange事件只有在输入框失焦时才会触发，无法实时监听输入变化，因此h5中新增了标准事件oninput，可以监听输入框实时输入变化，但IE9以下不支持oninput，需要使用onpropertychange。 oninput只能监听用户输入变化，不能监听js对输入框值的修改，而onpropertychange可以监听到任何输入框值的修改，但只有ie浏览器才能使用onpropertychange 场景一 搜索推荐在开发时，经常会开发搜索推荐的功能，搜索推荐在现在的应用中非常普遍。例如购物网站，会根据我们输入的关键字推荐相关的商品，每修改关键字就会推荐新的内容，例如淘宝： 搜索推荐 这个只需要使用oninput事件即可实现，需要注意对ie的兼容处理 1&lt;!DOCTYPE html&gt;2&lt;html lang=\"zh\"&gt;3&lt;head&gt;4 &lt;meta charset=\"UTF-8\"&gt;5 &lt;title&gt;&lt;/title&gt;6&lt;/head&gt;7&lt;body&gt;8 &lt;div class=\"search\"&gt;9 &lt;input id=\"key\" type=\"text\" name=\"key\"&gt;10 &lt;/div&gt;11 &lt;div class=\"recommand\"&gt;&lt;/div&gt;12 &lt;script&gt;13 var keyInput = document.getElementById('key');14 function fn() &#123;15 var key = keyInput.value;16 // ... 发起ajax请求17 // ... 渲染搜索结果18 // ... 注意节流处理19 &#125;20 if ('oninput' in keyInput) &#123; // 判断浏览器是否支持oninput21 keyInput.addEventListener('input', fn);22 &#125; else &#123;23 keyInput.onporpertychange = fn;24 &#125;25 &lt;/script&gt;26&lt;/body&gt;27&lt;/html&gt; 场景二 文本编辑器通常多行文本编辑使用textarea标签，textarea和input用法相同。但是当开发富文本编辑器时，往往使用div配合contenteditable来实现，这时将不能使用oninput等事件，有些需求比如在线代码编辑器的自动补全，依旧需要监听输入变化。 代码自动补全 解决方案可以使用keyup、mouseup事件实现，keyup监听按键松开时，mouseup监听鼠标松开时，比如粘贴剪切操作 1&lt;!DOCTYPE html&gt;2&lt;html lang=\"zh\"&gt;3&lt;head&gt;4 &lt;meta charset=\"UTF-8\"&gt;5 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;6 &lt;title&gt;&lt;/title&gt;7 &lt;style&gt;8 #text &#123;9 width: 300px;10 height: 200px;11 padding: 10px;12 border: 2px solid #e2e2e2;13 border-radius: 10px;14 outline: none;15 &#125;16 &lt;/style&gt;17&lt;/head&gt;18&lt;body&gt;19 &lt;div id=\"text\" contenteditable=\"true\"&gt;&lt;/div&gt;20 &lt;script&gt;21 var text = document.getElementById('text');22 var context = text.innerHTML23 var handle = function() &#123;24 if (context != text.innerHTML) &#123;25 context = text.innerHTML;26 console.log('内容发生了变化');27 &#125;28 &#125;29 var evt = ['keyup', 'mouseup'];30 evt.forEach(function(evt) &#123;31 document.addEventListener(evt, handle);32 &#125;);33 &lt;/script&gt;34&lt;/body&gt;35&lt;/html&gt;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"},{"name":"html","slug":"html","permalink":"http://blog.c2wei.cn/tags/html/"}]},{"title":"php安装拓展","slug":"php安装拓展","date":"2017-07-15T02:24:17.000Z","updated":"2019-12-25T15:07:39.749Z","comments":true,"path":"2017/07/15/php安装拓展/","link":"","permalink":"http://blog.c2wei.cn/2017/07/15/php%E5%AE%89%E8%A3%85%E6%8B%93%E5%B1%95/","excerpt":"","text":"php功能强大、开发效率高的很大一个原因就是它有丰富的拓展包，php拓展基于c语言和zend引擎编写，且php拓展在php代码执行前已经加载完成，因此性能良好 通过php -m命令可以查看当前php环境中安装了哪些拓展 也可以通过phpinfo函数查看，编写如下脚本 1&lt;?php2phpinfo(); 放到网站目录下，在浏览器中打开，可以详细的看到php和拓展的相关信息 一般来说，是不需要手动安装拓展的，因为php环境在一开始安装时往往就添加好了常用拓展，但在开发中也总会遇到需要再添加拓展的时候，比如redis、fileinfo等一些拓展 下载拓展php的拓展在pecl网站：http://pecl.php.net/ 基本都可以找到，搜索所需要的拓展，并下载相应版本 以redis为例，在网站右上角的输入框中输入redis，回车搜索 在搜索结果中找到redis，这里只有一条，点击进入 可以看到许多版本，选择对应版本，unix下载tgz文件，windows下载dll，我的环境是centos就下载tgz 我下载了最新稳定版本3.1.2 下载命令 1wget -c http:&#x2F;&#x2F;pecl.php.net&#x2F;get&#x2F;redis-3.1.2.tgz 安装拓展安装拓展需要php-dev工具包，我用的lnmp环境已经自带 解压.tgz文件得到拓展源码 1tar zxvf redis-3.1.2.tgz 进入源码目录 1cd redis-3.1.2.tgz 执行phpize 1phpize 会得到类似以下的输出： 1[root@ali redis-3.1.2]# phpize2Configuring for:3PHP Api Version: 201707184Zend Module Api No: 201707185Zend Extension Api No: 320170718 然后执行 1.&#x2F;configure --with-php-config&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin&#x2F;php-config #注意更改php-config地址 注意修改php-config为自己的地址，这个地址因环境而已，lnmp默认是以上的地址 没有提示错误就可以下一步了，执行 1make &amp;&amp; make install 当前登录用户不是root的话执行 1make &amp;&amp; sudo make install 输出结果的最后类似以下 1Build complete.2Don&#39;t forget to run &#39;make test&#39;.3Installing shared extensions: &#x2F;usr&#x2F;local&#x2F;php&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20170718&#x2F; 下载的拓展代码已经编译为了so文件，下一步要将so添加到php.ini中 复制拓展上一步拓展安装位置，编辑php.ini 1vim &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php.ini 添加 1extension&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20170718&#x2F;redis.so 保存重启php，执行php -m，如果列表中有redis说明已经添加好了","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://blog.c2wei.cn/tags/php/"}]},{"title":"配置ssh-config使用别名连接服务器","slug":"配置ssh-config使用别名连接服务器","date":"2017-05-11T08:33:53.000Z","updated":"2019-12-17T03:55:09.103Z","comments":true,"path":"2017/05/11/配置ssh-config使用别名连接服务器/","link":"","permalink":"http://blog.c2wei.cn/2017/05/11/%E9%85%8D%E7%BD%AEssh-config%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"我们在使用ssh进行远程连接时，每一次都输入远程主机的ip和密码是比较麻烦的，像服务器需要经常连接且如果有多个服务器也不方便记忆ip和密码 通过部署密钥和配置一个config，可以使用别名且不需要输入密码就可以连接 本地先生成ssh密钥，打开终端 1ssh-keygen -t rsa 一路回车即可， 然后将本地的ssh密钥发送到服务器建立信任 1ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub root@server_ip 这时通过命令ssh root@server_ip已经可以不需要密码登录服务器了 密钥生成一份可发送到多个服务器，不用为每个服务器单独生成 接下来配置别名，建立一个配置文件，执行vim ~/.ssh/config，内容如下 1Host ali #主机别名2HostName server_ip #主机ip3Port 22 #连接端口4User root #登录的用户5IdentityFile ~&#x2F;.ssh&#x2F;id_rsa #密钥地址67#还有主机就另起一行再写一份8Host tx #主机别名9HostName server_ip #主机ip10Port 22 #连接端口11User root #登录的用户12IdentityFile ~&#x2F;.ssh&#x2F;id_rsa #密钥地址1314...... 现在已经可以使用别名连接了，例 1ssh ali 就会登录到服务器了 如果有问题，把~/.ssh/config里#及#后面的注释删掉","categories":[],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://blog.c2wei.cn/tags/ssh/"}]},{"title":"使用webhooks实现git自动拉取代码","slug":"使用webhooks实现git自动拉取代码","date":"2017-04-25T09:19:49.000Z","updated":"2019-12-15T12:01:29.692Z","comments":true,"path":"2017/04/25/使用webhooks实现git自动拉取代码/","link":"","permalink":"http://blog.c2wei.cn/2017/04/25/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0git%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81/","excerpt":"","text":"将要自动拉取代码的仓库克隆到服务器，记住位置 以下示例用的仓库服务器地址为/home/wwwroot/website 查看服务器执行php使用的用户编辑php.ini，确保system,shell_exec函数没有被禁用 通过如下php脚本查看服务器是用哪个用户执行php程序的 1&lt;?php2system(\"whoami\"); 浏览器请求这个php文件，可以看到结果，我的是www用户 将/home/wwwroot/blog的所有者设为该www用户 1chown -R www:www /home/wwwroot/website 这样做的意义是保证hooks执行时拥有操作/home/wwwroot/website的权限 设置git基本信息这里设置的是www用户，即执行php使用的用户的git基本信息 1sudo -Hu www git config --global user.name &quot;username&quot;2sudo -Hu www git config --global user.email &quot;email@example.com&quot; 3&#x2F;&#x2F;邮箱要与github上一致 没有基本信息是无法拉取代码的 配置部署公钥先在服务器生成部署公钥 1sudo -Hu www ssh-keygen -t rsa -C &quot;your_name@example.com&quot; 2&#x2F;&#x2F;注意修改邮箱 查看密钥内容并复制 1cat &#x2F;home&#x2F;www&#x2F;.ssh&#x2F;id_rsa.pub 到github打开repositories的setting页-&gt;Deploy keys-&gt;Add deploy key，在key处填入复制的内容，title随意起一个用于辨别，点击Add key 配置webhooks到github打开repositories的setting页-&gt;Webhooks-&gt;Add Webhook: Payload URL填写hooks脚本的地址，如c2wei.cn/hooks.php，确保可以正确访问且和自动拉取的代码同服务器即可 Content Type保持默认 Secret填写一个密码，用于检验防止恶意请求，随意填写，如helloworld 剩下的勾选项保持默认，默认只在push事件发生时自定拉取，也可以配置更多事件 编写hooks编写hooks.php，并保证访问地址为上一步填写的，脚本内容如下 1&lt;?php2$secret &#x3D; &quot;helloworld&quot;; &#x2F;&#x2F;密钥，和上一步对应3$path &#x3D; &quot;&#x2F;home&#x2F;wwwroot&#x2F;website&quot;; &#x2F;&#x2F;自动拉取代码的文件目录4$signature &#x3D; $_SERVER[&quot;HTTP_X_HUB_SIGNATURE&quot;]; &#x2F;&#x2F;获取散列字符串5if($signature) &#123;6 $data &#x3D; file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;); &#x2F;&#x2F;获取收到的数据7 list($func, $hash) &#x3D; explode(&quot;&#x3D;&quot;, $signature, 2); &#x2F;&#x2F;获取散列算法、散列值8 if ($hash &#x3D;&#x3D;&#x3D; hash_hmac($func, $data, $secret)) &#123; 9 $response &#x3D; shell_exec(&quot;cd &quot;.$path.&quot; &amp;&amp; git pull 2&gt;&amp;1&quot;); &#x2F;&#x2F;拉取代码10 var_dump($response);11 &#125; else &#123;12 echo &quot;验证失败&quot;;13 &#125;14&#125; else &#123;15 echo &quot;密钥错误&quot;;16&#125; 保存脚本，本地push代码测试一下，OK 如果有问题检查文件权限问题，文件权限很关键，保证www用户拥有文件权限 在github的webhooks设置页可以查看hooks请求详情纠错","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://blog.c2wei.cn/tags/git/"}]},{"title":"js定时器实现动画","slug":"js定时器实现动画","date":"2017-04-16T11:33:09.000Z","updated":"2020-03-11T08:30:57.905Z","comments":true,"path":"2017/04/16/js定时器实现动画/","link":"","permalink":"http://blog.c2wei.cn/2017/04/16/js%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB/","excerpt":"","text":"现在网页动画效果有css3，有jquery的animate函数，可以方便的写出各种绚丽的效果。 但是，动画效果是怎么实现的？ 先看动画效果demo:js动画 动画实现原理动画片是通过一帧一帧的连续的图片生成的，js动画也是同理，例如网页中有个方块： 1#box &#123;2 width: 100px;3 height: 200px;4 background-color: yellow;5&#125; 1&lt;div id=\"box\"&gt;&lt;/div&gt; 现在实现一个动画，把方块的宽度慢慢变为200px，实现动画效果要一帧一帧的变化 假设这个过程在一秒内完成，如果设定10ms显示一帧，则一秒一共有100帧，也就是每10ms方块的宽度增加1px 可以通过js的定时器函数实现 1var target = 200;2var box = document.getElementById(\"box\");3var interval = setInterval(function () &#123;4 var width = box.offsetWidth;5 if (width &lt; target) &#123;6 box.style.width = (width+1) + 'px';7 &#125; else &#123;8 clearInterval(interval);9 &#125;10&#125;, 10); 样式获取问题在js中，只有少数几个属性有形如element.offsetWidth的函数获取当前样式， 而element.style只能获取和设置行内样式，外链样式需要通过getComputedStyle函数获取 在动画效果中，是需要不停比较当前样式值和目标样式值的 直接创建一个获取样式的函数： 1var getStyle = function (element, property) &#123;2 var value = element.style[property]3 if (value) &#123;4 return value;5 &#125; else &#123;6 return getComputedStyle(element, null)[property];7 &#125;8&#125; 函数封装我们把动画效果代码封装为一个函数animate 将速度提取出来，使其可定义，即动画执行时间 还要注意速度为负数的情况，即变小 1//定时器2var interval = null;3//time为动画时间 单位s4function animate(element, property, target, time) &#123;5 //设定每帧时间 单位ms6 var rate = 30; 7 //计算速度 每帧变动量8 var speed = (target - parseInt(getStyle(element, property))) / (time/rate*1000);9 clearInterval(interval); //先清空一次 避免动画未完成时函数又被调用10 interval = setInterval(function () &#123;11 //计算当前位置12 var offset = parseInt(getStyle(element, property));13 if (offset &lt; target &amp;&amp; speed &gt; 0) &#123; //变大时14 element.style[property] = (offset+speed)+'px' ;15 &#125; else if (offset &gt; target &amp;&amp; speed &lt; 0) &#123; //变小时16 element.style[property] = (offset+speed)+'px';17 &#125; else &#123; //结束时18 element.style[property] = target+'px';19 clearInterval(interval);20 &#125;21 &#125;, rate);22&#125; 后续问题思考多页面元素同时运动上一部份代码有一个明显的缺陷，interval作为公共变量被声明 如果有两个或多个元素同时使用animate函数，则interval变量也是同一个，同时工作的定时器只有一个 因此无法实现多页面元素的同时运动，解决方法是给每个元素分配一个定时器 直接给元素一个新属性，储存定时器，改动如下： 1function animate(element, property, target, time) &#123;2 element.interval = null; //interval直接设置为element的属性3 var rate = ...略 同上一部分4 var speed = ...略 同上一部分5 clearInterval(interval);6 element.interval = setInterval(function() &#123;7 ......省略8 &#125;)9&#125; 链式运动链式运动就是一个动画结束，另一个动画立即开始，一个动画接一个动画，形成动画链 可以通过添加一个回调函数fn实现，在动画结束时调用fn，fn传在参数里： 1function animate(element, property, target, time, fn) &#123;2 var rate = ......省略3 var speed = ......省略;4 clearInterval(element.interval);5 element.interval = setInterval(function () &#123;6 var offset = .....省略;7 if (判定动画未完成的条件) &#123;8 ........省略9 &#125; else &#123;10 element.style[property] = target+'px';11 clearInterval(interval);12 //重点 在动画结束时 若存在回调函数 调用回调函数13 if (fn) fn();14 &#125;15 &#125;, rate);16&#125; 使用方法 1animate(box, 'width', 200, 1, function() &#123;2 animate(box, 'height', 300, 2);3&#125;); 多样式同时运动把样式和样式目标用一个{}类型传入，遍历它操作 如： 1&#123;2 width: &#39;300px&#39;,3 height: &#39;300px&#39;4&#125; 代码： property为一个{}类型，链式效果用回调函数实现 1var animate = function (element, property, time, fn) &#123;2 var propertyList = Object.keys(property);3 if (propertyList.length &lt; 1) return;4 var rate = 30;5 var speedList = &#123;&#125;;6 for (var i = 0; i &lt; propertyList.length; i ++) &#123;7 var target = parseInt(property[propertyList[i]]);8 speedList[propertyList[i]] = (target - parseInt(getStyle(element, propertyList[i]))) / (time/rate*1000);9 &#125;10 clearInterval(element.interval);11 element.interval = setInterval(function () &#123;12 var completed = true;13 for (var i = 0; i &lt; propertyList.length; i ++) &#123;14 var offset = parseInt(getStyle(element, propertyList[i]));15 var target = parseInt(property[propertyList[i]]);16 var speed = speedList[propertyList[i]];17 if ((offset &lt; target &amp;&amp; speed &gt; 0)||18 (offset &gt; target &amp;&amp; speed &lt; 0)) &#123;19 completed = false;20 element.style[propertyList[i]] = (offset+speed)+'px';21 &#125; else &#123;22 element.style[propertyList[i]] = target+'px';23 &#125;24 &#125; 25 if (completed) &#123;26 clearInterval(element.interval)27 if (fn) fn();28 &#125;29 &#125;, rate);30&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.c2wei.cn/tags/javascript/"},{"name":"网页动画","slug":"网页动画","permalink":"http://blog.c2wei.cn/tags/%E7%BD%91%E9%A1%B5%E5%8A%A8%E7%94%BB/"}]},{"title":"ubuntu16更换主题","slug":"ubuntu16更换主题","date":"2017-04-11T12:56:44.000Z","updated":"2019-12-16T12:12:06.272Z","comments":true,"path":"2017/04/11/ubuntu16更换主题/","link":"","permalink":"http://blog.c2wei.cn/2017/04/11/ubuntu16%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/","excerpt":"","text":"美化任务栏1sudo apt-get install docky mac风格的任务栏 安装Unity Tweak Toolubuntu16.04默认使用的是Unity桌面环境，可以通过Unity Tweak Tool软件配置，这是一个非常好用的 Unity 图形化管理工具，有许多可用的主题图标，还可以修改工作区数量、热区等。 安装： 1sudo apt-get install unity-tweak-tool 命令行输入软件名称可以打开，即： 1unity-tweak-tool 安装好后就可以打开软件更换主题和图标了以下为几套好看的主题的安装命令 主题与图标Flatabulous主题1sudo add-apt-repository ppa:noobslab&#x2F;themes2sudo apt-get update3sudo apt-get install flatabulous-theme 该主题有配套的图标Ultra-flat:，安装方式如下：1sudo add-apt-repository ppa:noobslab&#x2F;icons2sudo apt-get update3sudo apt-get install4 ultra-flat-icons numix-gtk-theme主题1sudo add-apt-repository ppa:numix&#x2F;ppa2sudo apt-get update3sudo apt-get install numix-gtk-theme numix-icon-theme-circle paper-icon-theme图标1sudo add-apt-repository ppa:snwh&#x2F;pulp2sudo apt-get update3sudo apt-get install paper-icon-theme numix-icon-theme-circle图标1sudo add-apt-repository ppa:numix&#x2F;ppa2sudo apt-get update3sudo apt-get install numix-gtk-theme numix-icon-theme-circle xenlism-wildfire-icon-theme图标1sudo apt-key adv --keyserver keys.gnupg.net --recv-keys 90127F5B2echo &quot;deb http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;xenlism-wildfire&#x2F;repo deb&#x2F;&quot; | sudo tee -a &#x2F;etc&#x2F;apt&#x2F;sources.list 3sudo apt-get update 4sudo apt-get install xenlism-wildfire-icon-theme mac风格主题图标1sudo add-apt-repository ppa:noobslab&#x2F;macbuntu2sudo apt-get update3sudo apt-get install macbuntu-os-icons-lts-v74sudo apt-get install macbuntu-os-ithemes-lts-v7 更多主题和图标可以访问https://www.gnome-look.org获取更多主题和图标","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/tags/ubuntu/"}]},{"title":"ubuntu16执行apt-get报错","slug":"ubuntu16执行apt-get报错","date":"2017-04-10T12:39:51.000Z","updated":"2019-12-16T14:07:48.540Z","comments":true,"path":"2017/04/10/ubuntu16执行apt-get报错/","link":"","permalink":"http://blog.c2wei.cn/2017/04/10/ubuntu16%E6%89%A7%E8%A1%8Capt-get%E6%8A%A5%E9%94%99/","excerpt":"","text":"系统版本是Ubuntu 16.04 amd64 运行sudo apt-get update报错错误详情： 1Reading package lists... Done2E: Problem executing scripts APT::Update::Post-Invoke-Success3&#39;if &#x2F;usr&#x2F;bin&#x2F;test -w &#x2F;var&#x2F;cache&#x2F;app-info -a -e &#x2F;usr&#x2F;bin&#x2F;appstreamcli;4 then appstreamcli refresh &gt; &#x2F;dev&#x2F;null;5 fi&#39;6E: Sub-process returned an error code 在运行sudo apt-get update时出现如上信息，解决方法如下： 1sudo pkill -KILL appstreamcli2wget -P &#x2F;tmp https:&#x2F;&#x2F;launchpad.net&#x2F;ubuntu&#x2F;+archive&#x2F;primary&#x2F;+files&#x2F;appstream_0.9.4-1ubuntu1_amd64.deb 3wget -P https:&#x2F;&#x2F;launchpad.net&#x2F;ubuntu&#x2F;+archive&#x2F;primary&#x2F;+files&#x2F;libappstream3_0.9.4-1ubuntu1_amd64.deb4sudo dpkg -i &#x2F;tmp&#x2F;appstream_0.9.4-1ubuntu1_amd64.deb &#x2F;tmp&#x2F;libappstream3_0.9.4-1ubuntu1_amd64.deb 执行完上述命令之后再次运行sudo apt-get update就不会再出现上面的错误。 报错有锁错误详情： 1E: 无法获得锁 &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock - open (11: 资源暂时不可用)2E: 无法对目录 &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F; 加锁 运行和apt、apt-get有关的命令时出现上述问题，先确认是不是有另外的安装命令在进行，有的话等安装结束再执行，没有的话一般是上次apt/apt-get操作未正常结束，解决方法： 直接删除锁文件 1sudo rm -f &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;lock 删除掉就可以了","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/tags/ubuntu/"}]},{"title":"ubuntu下sublime不能输入中文解决","slug":"ubuntu下sublime不能输入中文解决","date":"2017-04-09T02:45:11.000Z","updated":"2019-12-15T12:01:06.668Z","comments":true,"path":"2017/04/09/ubuntu下sublime不能输入中文解决/","link":"","permalink":"http://blog.c2wei.cn/2017/04/09/ubuntu%E4%B8%8Bsublime%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E8%A7%A3%E5%86%B3/","excerpt":"","text":"本文适用于ubuntu16 让sublime支持gbk编码安装convertToUTF8插件首先，按住ctrl+shift+p，然后，在弹出的搜索框中输入install package最后，输入ConvertToUTF8，等待安装安装完成后重启subline Text3即可。 让sublime支持中文输入法本部分只包含让sublime支持中文输入法 下载我们需要的文件(在github上有编译好的共享库)，打开终端，输入： 1git clone https:&#x2F;&#x2F;github.com&#x2F;lyfeyaj&#x2F;sublime-text-imfix.git 将subl移动到/usr/bin/，并且将sublime-imfix.so移动到/opt/sublime_text/（sublime的安装目录）终端输入： 1cd ~&#x2F;sublime-text-imfix2sudo cp .&#x2F;lib&#x2F;libsublime-imfix.so &#x2F;opt&#x2F;sublime_text&#x2F;3sudo cp .&#x2F;src&#x2F;subl &#x2F;usr&#x2F;bin&#x2F; 用subl命令试试能不能启动sublime，如果成功启动的话，应该就可以输入中文了 终端输入： 1LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl 将上面的启动命令替换到启动器中 打开sublime-text.desktop 1cd &#x2F;usr&#x2F;share&#x2F;applications&#x2F;2sudo vim sublime_text.desktop 修改sublime-text.desktop 1[Desktop Entry]2Version&#x3D;1.03Type&#x3D;Application4Name&#x3D;Sublime Text5GenericName&#x3D;Text Editor6Comment&#x3D;Sophisticated text editor for code, markup and prose7Exec&#x3D;&#x2F;usr&#x2F;bin&#x2F;subl %F &#x2F;&#x2F;此行修改为 Exec&#x3D;bash -c &quot;LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl&quot;8Terminal&#x3D;false9MimeType&#x3D;text&#x2F;plain;10Icon&#x3D;sublime-text11Categories&#x3D;TextEditor;Development;Utility;12StartupNotify&#x3D;true13Actions&#x3D;Window;Document;1415X-Desktop-File-Install-Version&#x3D;0.221617[Desktop Action Window]18Name&#x3D;New Window19Exec&#x3D;&#x2F;usr&#x2F;bin&#x2F;subl -n&#x2F;&#x2F;此行修改为 Exec&#x3D;bash -c &quot;LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl&quot;20OnlyShowIn&#x3D;Unity;2122[Desktop Action Document]23Name&#x3D;New File24Exec&#x3D;&#x2F;usr&#x2F;bin&#x2F;subl --command new_file&#x2F;&#x2F;此行修改为 Exec&#x3D;bash -c &quot;LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl&quot;25OnlyShowIn&#x3D;Unity; sublime_text.desktop关键是修改形式为Exec=xxxx这几行，Exec=后跟的为启动器的执行命令 安装sublime没有找到启动器本部分从头开始安装sublime并添加中文输入支持 Ubuntu安装sublime到 sublime官网下载linux可用的sublime_text_3程序包(非安装包) 解压后得到一个sublime_text_3文件夹 把文件夹移动到/opt/ 1mv sublime_text_3 &#x2F;opt&#x2F; 然后重命名为sublime_text 1mv &#x2F;opt&#x2F;sublime_text_3 &#x2F;opt&#x2F;sublime_text 在sublime_text文件夹里可以找到一个sublime.desktop复制到桌面上（后面编辑、双击的全是桌面上这个sublime.desktop） 右击sublime.desktop 找到属性 改为可执行程序 这时候双击它应该可以启动sublime 下载和添加中文支持共享库下载我们需要的文件，打开终端，输入： 1git clone https:&#x2F;&#x2F;github.com&#x2F;lyfeyaj&#x2F;sublime-text-imfix.git 将subl移动到/usr/bin/，并且将sublime-imfix.so移动到/opt/sublime_text/（sublime的安装目录）终端输入： 1cd ~&#x2F;sublime-text-imfix2sudo cp .&#x2F;lib&#x2F;libsublime-imfix.so &#x2F;opt&#x2F;sublime_text&#x2F;3sudo cp .&#x2F;src&#x2F;subl &#x2F;usr&#x2F;bin&#x2F; 用subl命令试试能不能启动sublime，如果成功启动的话，应该就可以输入中文了。终端输入： 1LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl 将启动命令添加到sublime.desktop右击sublime.desktop 选择属性 找到命令一栏改成如下： 1bash - c &quot;LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so subl&quot; 这时候双击启动文件启动也能输入中文了 再从桌面上把sublime.desktop拖放到启动面板里 完成","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/categories/ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.c2wei.cn/tags/ubuntu/"}]}]}